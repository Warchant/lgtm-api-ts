// tslint:disable
/**
 * LGTM API specification
 * The REST API for LGTM provides data so that you can customize how you integrate LGTM analysis into your workflow. It includes the following resources:   * `/` ([API root](https://lgtm.com/help/lgtm/api/api-v1#LGTM-API-specification-API-root))&mdash;get version information or download the specification in OpenAPI format.   * `/projects` ([Projects](https://lgtm.com/help/lgtm/api/api-v1#LGTM-API-specification-Projects))&mdash;list projects, get a summary of the current status for a project, or add new projects.   * `/analyses` ([Analyses](https://lgtm.com/help/lgtm/api/api-v1#LGTM-API-specification-Analyses))&mdash;get a summary of results, download all the alerts, or trigger analysis for a specific commit.   * `/codereviews` ([Code reviews](https://lgtm.com/help/lgtm/api/api-v1#LGTM-API-specification-Code-reviews))&mdash;trigger code review for a patch, and view the results.   * `/operations` ([Operations](https://lgtm.com/help/lgtm/api/api-v1#LGTM-API-specification-Operations))&mdash;get information about long-running tasks, for example, analyses or code reviews that you\'ve requested.   * `/snapshots` ([Snapshots](https://lgtm.com/help/lgtm/api/api-v1#LGTM-API-specification-Snapshots))&mdash;download and upload databases representing a snapshot of a codebase.   * `/queryjobs` ([Query jobs](https://lgtm.com/help/lgtm/api/api-v1#LGTM-API-specification-Query-jobs))&mdash;submit queries to evaluate against existing projects, and download their results.   * `/system` ([System](https://lgtm.com/help/lgtm/api/api-v1#LGTM-API-specification-System))&mdash;get information on the health or usage of the system.  For an overview and getting started topics, see [API for LGTM](https://lgtm.com/help/lgtm/api/api-for-lgtm).
 *
 * The version of the OpenAPI document: v1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface Analysis
 */
export interface Analysis {
    /**
     * The analysis identifier.
     * @type {string}
     * @memberof Analysis
     */
    id?: string;
    /**
     *
     * @type {Project}
     * @memberof Analysis
     */
    project?: Project;
    /**
     * The commit identifier. The commit identifier is included only if the same commit was successfully analyzed for all languages. A detailed breakdown of which commit was analyzed for each language is provided in the `languages` property.
     * @type {string}
     * @memberof Analysis
     */
    commitId?: string;
    /**
     * Per-language information.
     * @type {Array<LanguageStats>}
     * @memberof Analysis
     */
    languages?: Array<LanguageStats>;
    /**
     * A page on LGTM to view the logs for this analysis.
     * @type {string}
     * @memberof Analysis
     */
    logUrl?: string;
    /**
     * A page on LGTM to view the results of this analysis.
     * @type {string}
     * @memberof Analysis
     */
    resultsUrl?: string;
}
/**
 *
 * @export
 * @interface CodeReview
 */
export interface CodeReview {
    /**
     * The identifier for the review.
     * @type {string}
     * @memberof CodeReview
     */
    id?: string;
    /**
     * A page on LGTM to view the status and results of this code review.
     * @type {string}
     * @memberof CodeReview
     */
    resultsUrl?: string;
    /**
     * The status of the code review.
     * @type {string}
     * @memberof CodeReview
     */
    status?: CodeReviewStatusEnum;
    /**
     * A summary of the current status of the code review.
     * @type {string}
     * @memberof CodeReview
     */
    statusMessage?: string;
    /**
     * Detailed information for each language analyzed.
     * @type {Array<CodereviewLanguages>}
     * @memberof CodeReview
     */
    languages?: Array<CodereviewLanguages>;
}

/**
    * @export
    * @enum {string}
    */
export enum CodeReviewStatusEnum {
    Pending = 'pending',
    Failure = 'failure',
    Success = 'success'
}

/**
 *
 * @export
 * @interface CodereviewAlerts
 */
export interface CodereviewAlerts {
    /**
     *
     * @type {Query}
     * @memberof CodereviewAlerts
     */
    query?: Query;
    /**
     * The number of alerts introduced by the patch for this query.
     * @type {number}
     * @memberof CodereviewAlerts
     */
    _new?: number;
    /**
     * The number of alerts fixed by the patch for this query.
     * @type {number}
     * @memberof CodereviewAlerts
     */
    fixed?: number;
}
/**
 *
 * @export
 * @interface CodereviewLanguages
 */
export interface CodereviewLanguages {
    /**
     * The language analyzed.
     * @type {string}
     * @memberof CodereviewLanguages
     */
    language?: string;
    /**
     * The status for analysis of this language.
     * @type {string}
     * @memberof CodereviewLanguages
     */
    status?: CodereviewLanguagesStatusEnum;
    /**
     * The current state of analysis of this langauge. When available, a summary of analysis results.
     * @type {string}
     * @memberof CodereviewLanguages
     */
    statusMessage?: string;
    /**
     * The total number of alerts introduced by the patch for this language.
     * @type {number}
     * @memberof CodereviewLanguages
     */
    _new?: number;
    /**
     * The total number of alerts fixed by the patch for this language.
     * @type {number}
     * @memberof CodereviewLanguages
     */
    fixed?: number;
    /**
     * The list of added and fixed alerts per query for this language.
     * @type {Array<CodereviewAlerts>}
     * @memberof CodereviewLanguages
     */
    alerts?: Array<CodereviewAlerts>;
}

/**
    * @export
    * @enum {string}
    */
export enum CodereviewLanguagesStatusEnum {
    Pending = 'pending',
    Failure = 'failure',
    Success = 'success'
}

/**
 *
 * @export
 * @interface Health
 */
export interface Health {
    /**
     * The status of the service.
     * @type {string}
     * @memberof Health
     */
    status?: HealthStatusEnum;
    /**
     * A description of the status of the service.
     * @type {string}
     * @memberof Health
     */
    description?: string;
    /**
     * Details of the health of the service. This contains information about the status of the components on which the service depends.
     * @type {{ [key: string]: Health; }}
     * @memberof Health
     */
    details?: { [key: string]: Health; };
}

/**
    * @export
    * @enum {string}
    */
export enum HealthStatusEnum {
    UNKNOWN = 'UNKNOWN',
    UP = 'UP',
    DOWN = 'DOWN'
}

/**
 *
 * @export
 * @interface LanguageStats
 */
export interface LanguageStats {
    /**
     * The short name for the language.
     * @type {string}
     * @memberof LanguageStats
     */
    language?: string;
    /**
     * The status of the analysis of this language.
     * @type {string}
     * @memberof LanguageStats
     */
    status?: LanguageStatsStatusEnum;
    /**
     * The number of alerts for this language.
     * @type {number}
     * @memberof LanguageStats
     */
    alerts?: number;
    /**
     * The number of lines of code for this language.
     * @type {number}
     * @memberof LanguageStats
     */
    lines?: number;
    /**
     * The latest successfully analyzed commit for the language. All statistics refer to this commit.
     * @type {string}
     * @memberof LanguageStats
     */
    commitId?: string;
    /**
     * The time of the commit.
     * @type {Date}
     * @memberof LanguageStats
     */
    commitDate?: Date;
    /**
     * The time the commit was analyzed.
     * @type {Date}
     * @memberof LanguageStats
     */
    analysisDate?: Date;
}

/**
    * @export
    * @enum {string}
    */
export enum LanguageStatsStatusEnum {
    Success = 'success',
    Failure = 'failure',
    Pending = 'pending'
}

/**
 *
 * @export
 * @interface Measurement
 */
export interface Measurement {
    /**
     * The date and time when this metric was computed.
     * @type {Date}
     * @memberof Measurement
     */
    timestamp?: Date;
    /**
     * The value of this metric at the timestamp reported.
     * @type {number}
     * @memberof Measurement
     */
    value?: number;
}
/**
 *
 * @export
 * @interface Metric
 */
export interface Metric {
    /**
     * The identifier by which this metric is referenced in the API.
     * @type {string}
     * @memberof Metric
     */
    metricId?: string;
    /**
     * A time series of values taken by the metric at different timestamps.
     * @type {Array<Measurement>}
     * @memberof Metric
     */
    measurements?: Array<Measurement>;
}
/**
 *
 * @export
 * @interface MetricName
 */
export interface MetricName {
    /**
     * The identifier by which this metric is referenced in the API.
     * @type {string}
     * @memberof MetricName
     */
    metricId?: string;
    /**
     * The name by which the metric is listed in the user interface.
     * @type {string}
     * @memberof MetricName
     */
    description?: string;
}
/**
 *
 * @export
 * @interface MetricsList
 */
export interface MetricsList {
    /**
     * The list of names and identifiers by which the metrics are referenced.
     * @type {Array<MetricName>}
     * @memberof MetricsList
     */
    data?: Array<MetricName>;
}
/**
 *
 * @export
 * @interface Operation
 */
export interface Operation {
    /**
     * The identifier for the operation.
     * @type {number}
     * @memberof Operation
     */
    id?: number;
    /**
     *
     * @type {{ [key: string]: UploadSession; }}
     * @memberof Operation
     */
    uploads?: { [key: string]: UploadSession; };
    /**
     * Status of the operation.
     * @type {string}
     * @memberof Operation
     */
    status?: OperationStatusEnum;
    /**
     *
     * @type {string}
     * @memberof Operation
     */
    taskType: OperationTaskTypeEnum;
    /**
     *
     * @type {Analysis | CodeReview | Queryjob}
     * @memberof Operation
     */
    taskResult?: Analysis | CodeReview | Queryjob;
    /**
     * The URL for the result of the task. For some operations, included only on completion.
     * @type {string}
     * @memberof Operation
     */
    taskResultUrl?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum OperationStatusEnum {
    Pending = 'pending',
    Done = 'done'
}
/**
    * @export
    * @enum {string}
    */
export enum OperationTaskTypeEnum {
    Analysis = 'analysis',
    Codereview = 'codereview',
    Queryjob = 'queryjob'
}

/**
 *
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * The numeric identifier of the project.
     * @type {number}
     * @memberof Project
     */
    id?: number;
    /**
     * The URL identifier of the project.
     * @type {string}
     * @memberof Project
     */
    urlIdentifier?: string;
    /**
     * The display name of the project.
     * @type {string}
     * @memberof Project
     */
    name?: string;
    /**
     * The full URL of the project on LGTM.
     * @type {string}
     * @memberof Project
     */
    url?: string;
}
/**
 *
 * @export
 * @interface ProjectDetails
 */
export interface ProjectDetails {
    /**
     * The numeric identifier of the project.
     * @type {number}
     * @memberof ProjectDetails
     */
    id?: number;
    /**
     * The URL identifier of the project.
     * @type {string}
     * @memberof ProjectDetails
     */
    urlIdentifier?: string;
    /**
     * The display name of the project.
     * @type {string}
     * @memberof ProjectDetails
     */
    name?: string;
    /**
     * The full URL of the project on LGTM.
     * @type {string}
     * @memberof ProjectDetails
     */
    url?: string;
    /**
     * Per-language information.
     * @type {Array<ProjectLanguageStats>}
     * @memberof ProjectDetails
     */
    languages?: Array<ProjectLanguageStats>;
}
/**
 *
 * @export
 * @interface ProjectDetailsAllOf
 */
export interface ProjectDetailsAllOf {
    /**
     * Per-language information.
     * @type {Array<ProjectLanguageStats>}
     * @memberof ProjectDetailsAllOf
     */
    languages?: Array<ProjectLanguageStats>;
}
/**
 *
 * @export
 * @interface ProjectLanguageStats
 */
export interface ProjectLanguageStats {
    /**
     * The short name for the language.
     * @type {string}
     * @memberof ProjectLanguageStats
     */
    language?: string;
    /**
     * The status of the analysis of this language.
     * @type {string}
     * @memberof ProjectLanguageStats
     */
    status?: ProjectLanguageStatsStatusEnum;
    /**
     * The number of alerts for this language.
     * @type {number}
     * @memberof ProjectLanguageStats
     */
    alerts?: number;
    /**
     * The number of lines of code for this language.
     * @type {number}
     * @memberof ProjectLanguageStats
     */
    lines?: number;
    /**
     * The latest successfully analyzed commit for the language. All statistics refer to this commit.
     * @type {string}
     * @memberof ProjectLanguageStats
     */
    commitId?: string;
    /**
     * The time of the commit.
     * @type {Date}
     * @memberof ProjectLanguageStats
     */
    commitDate?: Date;
    /**
     * The time the commit was analyzed.
     * @type {Date}
     * @memberof ProjectLanguageStats
     */
    analysisDate?: Date;
    /**
     * The grade of the code for this language.
     * @type {string}
     * @memberof ProjectLanguageStats
     */
    grade?: ProjectLanguageStatsGradeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ProjectLanguageStatsStatusEnum {
    Success = 'success',
    Failure = 'failure',
    Pending = 'pending'
}
/**
    * @export
    * @enum {string}
    */
export enum ProjectLanguageStatsGradeEnum {
    Aplus = 'A+',
    A = 'A',
    B = 'B',
    C = 'C',
    D = 'D',
    E = 'E'
}

/**
 *
 * @export
 * @interface ProjectLanguageStatsAllOf
 */
export interface ProjectLanguageStatsAllOf {
    /**
     * The grade of the code for this language.
     * @type {string}
     * @memberof ProjectLanguageStatsAllOf
     */
    grade?: ProjectLanguageStatsAllOfGradeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ProjectLanguageStatsAllOfGradeEnum {
    Aplus = 'A+',
    A = 'A',
    B = 'B',
    C = 'C',
    D = 'D',
    E = 'E'
}

/**
 *
 * @export
 * @interface ProjectList
 */
export interface ProjectList {
    /**
     * A single page of projects.
     * @type {Array<Project>}
     * @memberof ProjectList
     */
    data?: Array<Project>;
    /**
     * The URL to retrieve the next page of projects. Omitted if there is no next page.
     * @type {string}
     * @memberof ProjectList
     */
    nextPageUrl?: string;
}
/**
 *
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * The numeric identifier of the query.
     * @type {number}
     * @memberof Query
     */
    id?: number;
    /**
     * The name of the query pack that contains the query.
     * @type {string}
     * @memberof Query
     */
    pack?: string;
    /**
     * The `@name` of the query.
     * @type {string}
     * @memberof Query
     */
    name?: string;
    /**
     * The [language code](https://lgtm.com/help/lgtm/analysis-faqs#which-languages-are-supported) of the query.
     * @type {string}
     * @memberof Query
     */
    language?: string;
    /**
     *
     * @type {QueryProperties}
     * @memberof Query
     */
    properties?: QueryProperties;
    /**
     * A page on LGTM to view the details of the query.
     * @type {string}
     * @memberof Query
     */
    url?: string;
}
/**
 *
 * @export
 * @interface QueryProperties
 */
export interface QueryProperties {
    /**
     * The `@id` of the query.
     * @type {string}
     * @memberof QueryProperties
     */
    id?: string;
    /**
     * The `@name` of the query.
     * @type {string}
     * @memberof QueryProperties
     */
    name?: string;
    /**
     * The `@problem.severity` of the query.
     * @type {string}
     * @memberof QueryProperties
     */
    severity?: string;
    /**
     * The `@tags` associated with the query.
     * @type {Array<string>}
     * @memberof QueryProperties
     */
    tags?: Array<string>;
}
/**
 *
 * @export
 * @interface QueryResultEntry
 */
export interface QueryResultEntry {
    /**
     *
     * @type {number}
     * @memberof QueryResultEntry
     */
    line?: number;
    /**
     *
     * @type {string}
     * @memberof QueryResultEntry
     */
    file?: string;
    /**
     *
     * @type {string}
     * @memberof QueryResultEntry
     */
    value?: string;
    /**
     *
     * @type {string}
     * @memberof QueryResultEntry
     */
    url?: string;
}
/**
 *
 * @export
 * @interface Queryjob
 */
export interface Queryjob {
    /**
     * The identifier for the QueryJob.
     * @type {string}
     * @memberof Queryjob
     */
    id?: string;
    /**
     *
     * @type {QueryjobStats}
     * @memberof Queryjob
     */
    stats?: QueryjobStats;
    /**
     * URL to view the result of the query job.
     * @type {string}
     * @memberof Queryjob
     */
    resultUrl?: string;
}
/**
 *
 * @export
 * @interface QueryjobProjectResults
 */
export interface QueryjobProjectResults {
    /**
     *
     * @type {Project}
     * @memberof QueryjobProjectResults
     */
    project?: Project;
    /**
     * Columns returned by the query.
     * @type {Array<string>}
     * @memberof QueryjobProjectResults
     */
    columns?: Array<string>;
    /**
     * Results of the query divided by row.
     * @type {Array<Array<QueryResultEntry>>}
     * @memberof QueryjobProjectResults
     */
    data?: Array<Array<QueryResultEntry>>;
    /**
     * URL for retrieving the next part of the results (if applicable).
     * @type {string}
     * @memberof QueryjobProjectResults
     */
    next?: string;
}
/**
 *
 * @export
 * @interface QueryjobResultsOverview
 */
export interface QueryjobResultsOverview {
    /**
     *
     * @type {Array<QueryjobResultsOverviewEntry>}
     * @memberof QueryjobResultsOverview
     */
    data?: Array<QueryjobResultsOverviewEntry>;
    /**
     *
     * @type {string}
     * @memberof QueryjobResultsOverview
     */
    next?: string;
}
/**
 *
 * @export
 * @interface QueryjobResultsOverviewEntry
 */
export interface QueryjobResultsOverviewEntry {
    /**
     *
     * @type {Project}
     * @memberof QueryjobResultsOverviewEntry
     */
    project?: Project;
    /**
     * Describes whether the query was sucessfully executed against the project.
     * @type {string}
     * @memberof QueryjobResultsOverviewEntry
     */
    status?: QueryjobResultsOverviewEntryStatusEnum;
    /**
     * Number of results returned by the query. This is broken down further into `internal` and `external` results. Only applies if `status` is `success`.
     * @type {number}
     * @memberof QueryjobResultsOverviewEntry
     */
    total?: number;
    /**
     * Number of results that refer to elements within the source tree. Only applies if `status` is `success`.
     * @type {number}
     * @memberof QueryjobResultsOverviewEntry
     */
    internal?: number;
    /**
     * Number of results that refer to elements outside the source tree (e.g., libraries). Only applies if `status` is `success`.
     * @type {number}
     * @memberof QueryjobResultsOverviewEntry
     */
    external?: number;
    /**
     * Error message. Only applies if `status` is `error`.
     * @type {string}
     * @memberof QueryjobResultsOverviewEntry
     */
    error?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum QueryjobResultsOverviewEntryStatusEnum {
    Success = 'success',
    Error = 'error'
}

/**
 *
 * @export
 * @interface QueryjobStats
 */
export interface QueryjobStats {
    /**
     * The number of projects for which the query completed succesfully. These are broken down further between the ones that have results (`success-with-result`) and the ones that do not (`success-without-result`): `successful = success-with-result + success-without-result`.
     * @type {number}
     * @memberof QueryjobStats
     */
    successful?: number;
    /**
     * The number of projects for which the query returned results.
     * @type {number}
     * @memberof QueryjobStats
     */
    successWithResult?: number;
    /**
     * The number of projects for which the query was successful but returned no results.
     * @type {number}
     * @memberof QueryjobStats
     */
    successWithoutResult?: number;
    /**
     * The number of projects for which the query failed.
     * @type {number}
     * @memberof QueryjobStats
     */
    failed?: number;
    /**
     * The number of projects scheduled for execution but pending. For very large jobs, not all projects are scheduled at the same time. Therefore, this number might increase as more projects are scheduled. This means that `successful + failed + pending` might be smaller than the total number of project that will be analyzed.
     * @type {number}
     * @memberof QueryjobStats
     */
    pending?: number;
}
/**
 *
 * @export
 * @interface UploadSession
 */
export interface UploadSession {
    /**
     * The identifier of the upload session
     * @type {string}
     * @memberof UploadSession
     */
    id?: string;
    /**
     * The URL for uploading file content.
     * @type {string}
     * @memberof UploadSession
     */
    url?: string;
}
/**
 *
 * @export
 * @interface Version
 */
export interface Version {
    /**
     * The version number of the API.
     * @type {string}
     * @memberof Version
     */
    apiVersion?: string;
}

/**
 * APIRootApi - axios parameter creator
 * @export
 */
export const APIRootApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the specification of this API in [OpenAPI](https://github.com/OAI/OpenAPI-Specification) format. This endpoint does not require an access token. This makes it easier for you to use the specification with third-party tools.
         * @summary API specification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpec(options: any = {}): RequestArgs {
            const localVarPath = `/openapi`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the version information of this API.
         * @summary Version information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options: any = {}): RequestArgs {
            const localVarPath = `/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIRootApi - functional programming interface
 * @export
 */
export const APIRootApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get the specification of this API in [OpenAPI](https://github.com/OAI/OpenAPI-Specification) format. This endpoint does not require an access token. This makes it easier for you to use the specification with third-party tools.
         * @summary API specification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpec(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = APIRootApiAxiosParamCreator(configuration).getSpec(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the version information of this API.
         * @summary Version information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Version> {
            const localVarAxiosArgs = APIRootApiAxiosParamCreator(configuration).getVersion(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * APIRootApi - factory interface
 * @export
 */
export const APIRootApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get the specification of this API in [OpenAPI](https://github.com/OAI/OpenAPI-Specification) format. This endpoint does not require an access token. This makes it easier for you to use the specification with third-party tools.
         * @summary API specification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpec(options?: any) {
            return APIRootApiFp(configuration).getSpec(options)(axios, basePath);
        },
        /**
         * Get the version information of this API.
         * @summary Version information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: any) {
            return APIRootApiFp(configuration).getVersion(options)(axios, basePath);
        },
    };
};

/**
 * APIRootApi - object-oriented interface
 * @export
 * @class APIRootApi
 * @extends {BaseAPI}
 */
export class APIRootApi extends BaseAPI {
    /**
     * Get the specification of this API in [OpenAPI](https://github.com/OAI/OpenAPI-Specification) format. This endpoint does not require an access token. This makes it easier for you to use the specification with third-party tools.
     * @summary API specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIRootApi
     */
    public getSpec(options?: any) {
        return APIRootApiFp(this.configuration).getSpec(options)(this.axios, this.basePath);
    }

    /**
     * Get the version information of this API.
     * @summary Version information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIRootApi
     */
    public getVersion(options?: any) {
        return APIRootApiFp(this.configuration).getVersion(options)(this.axios, this.basePath);
    }

}


/**
 * AnalysesApi - axios parameter creator
 * @export
 */
export const AnalysesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Download all the alerts found by an analysis. Use an `Accept:` to specify the output media type as either CSV or [SARIF](https://help.semmle.com/wiki/display/SD/SARIF+results+file):   - `application/sarif+json`: Alerts in SARIF format. If no version is specified the latest supported SARIF version is used. - `application/json`: Alerts in SARIF format (*deprecated*).    If no version is specified, [SARIF 2.0.0](http://docs.oasis-open.org/sarif/sarif/v2.0/sarif-v2.0.html)    is used for backwards compatibility.  - `text/csv`: Alerts in CSV format. The `text/csv` media type has two optional parameters:    - `charset`: determines the character encoding of the text, by default UTF-8.    - `header`: determines whether a header row with column names is `present` or `absent`.       The default value for this parameter is `present`.       For example, an Accept header with value `text/csv; header=absent`        would result in CSV output without a header row.         To find the analysis identifier for a commit, use the `/analyses/{project-id}/commits/{commit-id}`  endpoint. For more information, see [Get analysis summary for a specific commit](https://lgtm.com/help/lgtm/api/api-v1#opIdgetAnalysisForCommit).
         * @summary Get detailed alert information
         * @param {string} analysisId The analysis identifier.
         * @param {string} [sarifVersion] The desired version of the SARIF format. Currently supported versions are &#x60;1.0.0&#x60;, &#x60;2.0.0&#x60;, and &#x60;2.1.0&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlerts(analysisId: string, sarifVersion?: string, options: any = {}): RequestArgs {
            // verify required parameter 'analysisId' is not null or undefined
            if (analysisId === null || analysisId === undefined) {
                throw new RequiredError('analysisId','Required parameter analysisId was null or undefined when calling getAlerts.');
            }
            const localVarPath = `/analyses/{analysis-id}/alerts`
                .replace(`{${"analysis-id"}}`, encodeURIComponent(String(analysisId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (sarifVersion !== undefined) {
                localVarQueryParameter['sarif-version'] = sarifVersion;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a summary of the analysis results for a specific analysis identifier.  To find the analysis identifier for a commit, use the `/analyses/{project-id}/commits/{commit-id}` endpoint. For more information, see [Get analysis summary for a specific commit](https://lgtm.com/help/lgtm/api/api-v1#opIdgetAnalysisForCommit).  This endpoint reports the commit analyzed and a summary of the results for each language. Alternatively, you can use this identifier to download full details  of all the alerts found by the analysis. For more information, see [Get detailed alert information](https://lgtm.com/help/lgtm/api/api-v1#opIdgetAlerts).
         * @summary Get analysis summary
         * @param {string} analysisId The analysis identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysis(analysisId: string, options: any = {}): RequestArgs {
            // verify required parameter 'analysisId' is not null or undefined
            if (analysisId === null || analysisId === undefined) {
                throw new RequiredError('analysisId','Required parameter analysisId was null or undefined when calling getAnalysis.');
            }
            const localVarPath = `/analyses/{analysis-id}`
                .replace(`{${"analysis-id"}}`, encodeURIComponent(String(analysisId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a summary of the analysis results for a specific commit, or the latest commit, to a project. (For projects configured for sparse or upload analysis, only `latest` is supported.)   This endpoint reports a summary of results for each language, and also the analysis identifier. You can use the analysis identifier to download full details of all the alerts  found by the analysis. For more information, see [Get detailed alert information](https://lgtm.com/help/lgtm/api/api-v1#opIdgetAlerts).
         * @summary Get analysis summary for a specific commit
         * @param {number} projectId The numeric project identifier.
         * @param {string} commitId The identifier of a specific commit. Alternatively, use &#x60;latest&#x60; for the most recent analyzed commit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisForCommit(projectId: number, commitId: string, options: any = {}): RequestArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling getAnalysisForCommit.');
            }
            // verify required parameter 'commitId' is not null or undefined
            if (commitId === null || commitId === undefined) {
                throw new RequiredError('commitId','Required parameter commitId was null or undefined when calling getAnalysisForCommit.');
            }
            const localVarPath = `/analyses/{project-id}/commits/{commit-id}`
                .replace(`{${"project-id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"commit-id"}}`, encodeURIComponent(String(commitId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger the analysis of a specific commit to a project. If a previous attempt to analyze that commit failed, this triggers a fresh analysis.  This is supported for all LGTM projects, regardless of repository type or host. The commit must be available in the main repository, but can be on a branch that isn\'t tracked by LGTM. For both LGTM.com and LGTM Enterprise, you must include an access token with the `analyses:write` scope.  When you request the analysis of a commit, the API returns: - `operation-id`: used to track the status of the task using the `/operations` endpoint. For more information, see [Get operation status](https://lgtm.com/help/lgtm/api/api-v1#opIdgetOperation). - `status`: initially pending. - `task-result`: containing information about the progress and results of the analysis.
         * @summary Run analysis of a specific commit
         * @param {number} projectId The numeric project identifier.
         * @param {string} commit The identifier of the commit to analyze.
         * @param {Array<string>} [language] The language codes of the languages to analyze. For a list of available languages, see [Supported languages](https://lgtm.com/help/lgtm/analysis-faqs#which-languages-are-supported). To specify more than one language, this parameter can be repeated. If no language is specified, all the project\&#39;s languages will be analyzed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAnalysis(projectId: number, commit: string, language?: Array<string>, options: any = {}): RequestArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling requestAnalysis.');
            }
            // verify required parameter 'commit' is not null or undefined
            if (commit === null || commit === undefined) {
                throw new RequiredError('commit','Required parameter commit was null or undefined when calling requestAnalysis.');
            }
            const localVarPath = `/analyses/{project-id}`
                .replace(`{${"project-id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (commit !== undefined) {
                localVarQueryParameter['commit'] = commit;
            }

            if (language) {
                localVarQueryParameter['language'] = language;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalysesApi - functional programming interface
 * @export
 */
export const AnalysesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Download all the alerts found by an analysis. Use an `Accept:` to specify the output media type as either CSV or [SARIF](https://help.semmle.com/wiki/display/SD/SARIF+results+file):   - `application/sarif+json`: Alerts in SARIF format. If no version is specified the latest supported SARIF version is used. - `application/json`: Alerts in SARIF format (*deprecated*).    If no version is specified, [SARIF 2.0.0](http://docs.oasis-open.org/sarif/sarif/v2.0/sarif-v2.0.html)    is used for backwards compatibility.  - `text/csv`: Alerts in CSV format. The `text/csv` media type has two optional parameters:    - `charset`: determines the character encoding of the text, by default UTF-8.    - `header`: determines whether a header row with column names is `present` or `absent`.       The default value for this parameter is `present`.       For example, an Accept header with value `text/csv; header=absent`        would result in CSV output without a header row.         To find the analysis identifier for a commit, use the `/analyses/{project-id}/commits/{commit-id}`  endpoint. For more information, see [Get analysis summary for a specific commit](https://lgtm.com/help/lgtm/api/api-v1#opIdgetAnalysisForCommit).
         * @summary Get detailed alert information
         * @param {string} analysisId The analysis identifier.
         * @param {string} [sarifVersion] The desired version of the SARIF format. Currently supported versions are &#x60;1.0.0&#x60;, &#x60;2.0.0&#x60;, and &#x60;2.1.0&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlerts(analysisId: string, sarifVersion?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = AnalysesApiAxiosParamCreator(configuration).getAlerts(analysisId, sarifVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a summary of the analysis results for a specific analysis identifier.  To find the analysis identifier for a commit, use the `/analyses/{project-id}/commits/{commit-id}` endpoint. For more information, see [Get analysis summary for a specific commit](https://lgtm.com/help/lgtm/api/api-v1#opIdgetAnalysisForCommit).  This endpoint reports the commit analyzed and a summary of the results for each language. Alternatively, you can use this identifier to download full details  of all the alerts found by the analysis. For more information, see [Get detailed alert information](https://lgtm.com/help/lgtm/api/api-v1#opIdgetAlerts).
         * @summary Get analysis summary
         * @param {string} analysisId The analysis identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysis(analysisId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Analysis> {
            const localVarAxiosArgs = AnalysesApiAxiosParamCreator(configuration).getAnalysis(analysisId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a summary of the analysis results for a specific commit, or the latest commit, to a project. (For projects configured for sparse or upload analysis, only `latest` is supported.)   This endpoint reports a summary of results for each language, and also the analysis identifier. You can use the analysis identifier to download full details of all the alerts  found by the analysis. For more information, see [Get detailed alert information](https://lgtm.com/help/lgtm/api/api-v1#opIdgetAlerts).
         * @summary Get analysis summary for a specific commit
         * @param {number} projectId The numeric project identifier.
         * @param {string} commitId The identifier of a specific commit. Alternatively, use &#x60;latest&#x60; for the most recent analyzed commit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisForCommit(projectId: number, commitId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Analysis>> {
            const localVarAxiosArgs = AnalysesApiAxiosParamCreator(configuration).getAnalysisForCommit(projectId, commitId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Trigger the analysis of a specific commit to a project. If a previous attempt to analyze that commit failed, this triggers a fresh analysis.  This is supported for all LGTM projects, regardless of repository type or host. The commit must be available in the main repository, but can be on a branch that isn\'t tracked by LGTM. For both LGTM.com and LGTM Enterprise, you must include an access token with the `analyses:write` scope.  When you request the analysis of a commit, the API returns: - `operation-id`: used to track the status of the task using the `/operations` endpoint. For more information, see [Get operation status](https://lgtm.com/help/lgtm/api/api-v1#opIdgetOperation). - `status`: initially pending. - `task-result`: containing information about the progress and results of the analysis.
         * @summary Run analysis of a specific commit
         * @param {number} projectId The numeric project identifier.
         * @param {string} commit The identifier of the commit to analyze.
         * @param {Array<string>} [language] The language codes of the languages to analyze. For a list of available languages, see [Supported languages](https://lgtm.com/help/lgtm/analysis-faqs#which-languages-are-supported). To specify more than one language, this parameter can be repeated. If no language is specified, all the project\&#39;s languages will be analyzed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAnalysis(projectId: number, commit: string, language?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation> {
            const localVarAxiosArgs = AnalysesApiAxiosParamCreator(configuration).requestAnalysis(projectId, commit, language, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AnalysesApi - factory interface
 * @export
 */
export const AnalysesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Download all the alerts found by an analysis. Use an `Accept:` to specify the output media type as either CSV or [SARIF](https://help.semmle.com/wiki/display/SD/SARIF+results+file):   - `application/sarif+json`: Alerts in SARIF format. If no version is specified the latest supported SARIF version is used. - `application/json`: Alerts in SARIF format (*deprecated*).    If no version is specified, [SARIF 2.0.0](http://docs.oasis-open.org/sarif/sarif/v2.0/sarif-v2.0.html)    is used for backwards compatibility.  - `text/csv`: Alerts in CSV format. The `text/csv` media type has two optional parameters:    - `charset`: determines the character encoding of the text, by default UTF-8.    - `header`: determines whether a header row with column names is `present` or `absent`.       The default value for this parameter is `present`.       For example, an Accept header with value `text/csv; header=absent`        would result in CSV output without a header row.         To find the analysis identifier for a commit, use the `/analyses/{project-id}/commits/{commit-id}`  endpoint. For more information, see [Get analysis summary for a specific commit](https://lgtm.com/help/lgtm/api/api-v1#opIdgetAnalysisForCommit).
         * @summary Get detailed alert information
         * @param {string} analysisId The analysis identifier.
         * @param {string} [sarifVersion] The desired version of the SARIF format. Currently supported versions are &#x60;1.0.0&#x60;, &#x60;2.0.0&#x60;, and &#x60;2.1.0&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlerts(analysisId: string, sarifVersion?: string, options?: any) {
            return AnalysesApiFp(configuration).getAlerts(analysisId, sarifVersion, options)(axios, basePath);
        },
        /**
         * Get a summary of the analysis results for a specific analysis identifier.  To find the analysis identifier for a commit, use the `/analyses/{project-id}/commits/{commit-id}` endpoint. For more information, see [Get analysis summary for a specific commit](https://lgtm.com/help/lgtm/api/api-v1#opIdgetAnalysisForCommit).  This endpoint reports the commit analyzed and a summary of the results for each language. Alternatively, you can use this identifier to download full details  of all the alerts found by the analysis. For more information, see [Get detailed alert information](https://lgtm.com/help/lgtm/api/api-v1#opIdgetAlerts).
         * @summary Get analysis summary
         * @param {string} analysisId The analysis identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysis(analysisId: string, options?: any) {
            return AnalysesApiFp(configuration).getAnalysis(analysisId, options)(axios, basePath);
        },
        /**
         * Get a summary of the analysis results for a specific commit, or the latest commit, to a project. (For projects configured for sparse or upload analysis, only `latest` is supported.)   This endpoint reports a summary of results for each language, and also the analysis identifier. You can use the analysis identifier to download full details of all the alerts  found by the analysis. For more information, see [Get detailed alert information](https://lgtm.com/help/lgtm/api/api-v1#opIdgetAlerts).
         * @summary Get analysis summary for a specific commit
         * @param {number} projectId The numeric project identifier.
         * @param {string} commitId The identifier of a specific commit. Alternatively, use &#x60;latest&#x60; for the most recent analyzed commit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisForCommit(projectId: number, commitId: string, options?: any) {
            return AnalysesApiFp(configuration).getAnalysisForCommit(projectId, commitId, options)(axios, basePath);
        },
        /**
         * Trigger the analysis of a specific commit to a project. If a previous attempt to analyze that commit failed, this triggers a fresh analysis.  This is supported for all LGTM projects, regardless of repository type or host. The commit must be available in the main repository, but can be on a branch that isn\'t tracked by LGTM. For both LGTM.com and LGTM Enterprise, you must include an access token with the `analyses:write` scope.  When you request the analysis of a commit, the API returns: - `operation-id`: used to track the status of the task using the `/operations` endpoint. For more information, see [Get operation status](https://lgtm.com/help/lgtm/api/api-v1#opIdgetOperation). - `status`: initially pending. - `task-result`: containing information about the progress and results of the analysis.
         * @summary Run analysis of a specific commit
         * @param {number} projectId The numeric project identifier.
         * @param {string} commit The identifier of the commit to analyze.
         * @param {Array<string>} [language] The language codes of the languages to analyze. For a list of available languages, see [Supported languages](https://lgtm.com/help/lgtm/analysis-faqs#which-languages-are-supported). To specify more than one language, this parameter can be repeated. If no language is specified, all the project\&#39;s languages will be analyzed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAnalysis(projectId: number, commit: string, language?: Array<string>, options?: any) {
            return AnalysesApiFp(configuration).requestAnalysis(projectId, commit, language, options)(axios, basePath);
        },
    };
};

/**
 * AnalysesApi - object-oriented interface
 * @export
 * @class AnalysesApi
 * @extends {BaseAPI}
 */
export class AnalysesApi extends BaseAPI {
    /**
     * Download all the alerts found by an analysis. Use an `Accept:` to specify the output media type as either CSV or [SARIF](https://help.semmle.com/wiki/display/SD/SARIF+results+file):   - `application/sarif+json`: Alerts in SARIF format. If no version is specified the latest supported SARIF version is used. - `application/json`: Alerts in SARIF format (*deprecated*).    If no version is specified, [SARIF 2.0.0](http://docs.oasis-open.org/sarif/sarif/v2.0/sarif-v2.0.html)    is used for backwards compatibility.  - `text/csv`: Alerts in CSV format. The `text/csv` media type has two optional parameters:    - `charset`: determines the character encoding of the text, by default UTF-8.    - `header`: determines whether a header row with column names is `present` or `absent`.       The default value for this parameter is `present`.       For example, an Accept header with value `text/csv; header=absent`        would result in CSV output without a header row.         To find the analysis identifier for a commit, use the `/analyses/{project-id}/commits/{commit-id}`  endpoint. For more information, see [Get analysis summary for a specific commit](https://lgtm.com/help/lgtm/api/api-v1#opIdgetAnalysisForCommit).
     * @summary Get detailed alert information
     * @param {string} analysisId The analysis identifier.
     * @param {string} [sarifVersion] The desired version of the SARIF format. Currently supported versions are &#x60;1.0.0&#x60;, &#x60;2.0.0&#x60;, and &#x60;2.1.0&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public getAlerts(analysisId: string, sarifVersion?: string, options?: any) {
        return AnalysesApiFp(this.configuration).getAlerts(analysisId, sarifVersion, options)(this.axios, this.basePath);
    }

    /**
     * Get a summary of the analysis results for a specific analysis identifier.  To find the analysis identifier for a commit, use the `/analyses/{project-id}/commits/{commit-id}` endpoint. For more information, see [Get analysis summary for a specific commit](https://lgtm.com/help/lgtm/api/api-v1#opIdgetAnalysisForCommit).  This endpoint reports the commit analyzed and a summary of the results for each language. Alternatively, you can use this identifier to download full details  of all the alerts found by the analysis. For more information, see [Get detailed alert information](https://lgtm.com/help/lgtm/api/api-v1#opIdgetAlerts).
     * @summary Get analysis summary
     * @param {string} analysisId The analysis identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public getAnalysis(analysisId: string, options?: any) {
        return AnalysesApiFp(this.configuration).getAnalysis(analysisId, options)(this.axios, this.basePath);
    }

    /**
     * Get a summary of the analysis results for a specific commit, or the latest commit, to a project. (For projects configured for sparse or upload analysis, only `latest` is supported.)   This endpoint reports a summary of results for each language, and also the analysis identifier. You can use the analysis identifier to download full details of all the alerts  found by the analysis. For more information, see [Get detailed alert information](https://lgtm.com/help/lgtm/api/api-v1#opIdgetAlerts).
     * @summary Get analysis summary for a specific commit
     * @param {number} projectId The numeric project identifier.
     * @param {string} commitId The identifier of a specific commit. Alternatively, use &#x60;latest&#x60; for the most recent analyzed commit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public getAnalysisForCommit(projectId: number, commitId: string, options?: any) {
        return AnalysesApiFp(this.configuration).getAnalysisForCommit(projectId, commitId, options)(this.axios, this.basePath);
    }

    /**
     * Trigger the analysis of a specific commit to a project. If a previous attempt to analyze that commit failed, this triggers a fresh analysis.  This is supported for all LGTM projects, regardless of repository type or host. The commit must be available in the main repository, but can be on a branch that isn\'t tracked by LGTM. For both LGTM.com and LGTM Enterprise, you must include an access token with the `analyses:write` scope.  When you request the analysis of a commit, the API returns: - `operation-id`: used to track the status of the task using the `/operations` endpoint. For more information, see [Get operation status](https://lgtm.com/help/lgtm/api/api-v1#opIdgetOperation). - `status`: initially pending. - `task-result`: containing information about the progress and results of the analysis.
     * @summary Run analysis of a specific commit
     * @param {number} projectId The numeric project identifier.
     * @param {string} commit The identifier of the commit to analyze.
     * @param {Array<string>} [language] The language codes of the languages to analyze. For a list of available languages, see [Supported languages](https://lgtm.com/help/lgtm/analysis-faqs#which-languages-are-supported). To specify more than one language, this parameter can be repeated. If no language is specified, all the project\&#39;s languages will be analyzed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public requestAnalysis(projectId: number, commit: string, language?: Array<string>, options?: any) {
        return AnalysesApiFp(this.configuration).requestAnalysis(projectId, commit, language, options)(this.axios, this.basePath);
    }

}


/**
 * CodeReviewsApi - axios parameter creator
 * @export
 */
export const CodeReviewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the results of a code review using the review identifier for the task.  When you request a code review, the response includes a task result URL of the form: `/codereviews/{review-id}`.  This endpoint reports the results of a complete code review, or the status of a review  that\'s still in progress.
         * @summary Get results of code review
         * @param {string} reviewId The identifier for the review (from the &#x60;task-result-url&#x60;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeReview(reviewId: string, options: any = {}): RequestArgs {
            // verify required parameter 'reviewId' is not null or undefined
            if (reviewId === null || reviewId === undefined) {
                throw new RequiredError('reviewId','Required parameter reviewId was null or undefined when calling getCodeReview.');
            }
            const localVarPath = `/codereviews/{review-id}`
                .replace(`{${"review-id"}}`, encodeURIComponent(String(reviewId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger the code review of a patch. This is available for projects with Git repositories.  Your request must include:    * Identifier for the base commit   * Patch generated using `git diff --binary` (see [git diff](https://git-scm.com/docs/git-diff))   * Header `Content-Type: application/octet-stream`   * For both LGTM.com and LGTM Enterprise, an access token with the `codereviews:write` scope  Note that if you make a request using Curl, you\'ll also need to add `--data-binary` to the request to ensure that the patch you supply in the body is sent with newlines unchanged. You can track the progress of the review using the task result URL returned on creation of the task, or by calling the `/operations` endpoint with the operations identifier returned by the request. For more information, see [Get operation status](https://lgtm.com/help/lgtm/api/api-v1#opIdgetOperation). Alternatively, if you supply a callback URL you\'ll get a post-back automatically on completion of the review.  When the review is complete, you can access the results using the task result URL.
         * @summary Run code review for a patch
         * @param {number} projectId The numeric project identifier.
         * @param {string} base The identifier for the base commit.
         * @param {number} externalId Your reference number for the code review.
         * @param {any} body The patch containing the code changes for review.
         * @param {string} [reviewUrl] An informative back-link to an external system.
         * @param {string} [callbackUrl] The callback URL for LGTM to post to on completion of the review. When the code review is complete, the API sends an HTTP POST request to the callback URL with the result of the code review in the request body. The code review results in the request body are identical to the results accessed through the [&#x60;/codereviews/{review-id}&#x60;](https://lgtm.com/help/lgtm/api/api-v1#opIdgetCodeReview) end-point. If you specify a &#x60;callback-secret&#x60;, the request also includes an &#x60;x-lgtm-signature&#x60; header with a digital signature of the request\&#39;s contents.
         * @param {string} [callbackSecret] The &#x60;callback-secret&#x60; is used to compute a signature which is included in the &#x60;x-lgtm-signature&#x60; header of the callback response. The receiver of the callback can check the validity of the response by computing the signature using HMAC-SHA1 and verifying that it matches the &#x60;x-lgtm-signature&#x60; header value. The HMAC algorithm requires byte sequences as inputs for both the secret and the message. The callback secret string must be converted to bytes using UTF-8 encoding. The response body should ideally be read as a plain byte sequence. Conversion to, for example a JSON object, and back to a byte sequence might change the formatting, and would invalidate the signature.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestReview(projectId: number, base: string, externalId: number, body: any, reviewUrl?: string, callbackUrl?: string, callbackSecret?: string, options: any = {}): RequestArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling requestReview.');
            }
            // verify required parameter 'base' is not null or undefined
            if (base === null || base === undefined) {
                throw new RequiredError('base','Required parameter base was null or undefined when calling requestReview.');
            }
            // verify required parameter 'externalId' is not null or undefined
            if (externalId === null || externalId === undefined) {
                throw new RequiredError('externalId','Required parameter externalId was null or undefined when calling requestReview.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling requestReview.');
            }
            const localVarPath = `/codereviews/{project-id}`
                .replace(`{${"project-id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (base !== undefined) {
                localVarQueryParameter['base'] = base;
            }

            if (externalId !== undefined) {
                localVarQueryParameter['external-id'] = externalId;
            }

            if (reviewUrl !== undefined) {
                localVarQueryParameter['review-url'] = reviewUrl;
            }

            if (callbackUrl !== undefined) {
                localVarQueryParameter['callback-url'] = callbackUrl;
            }

            if (callbackSecret !== undefined) {
                localVarQueryParameter['callback-secret'] = callbackSecret;
            }



            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CodeReviewsApi - functional programming interface
 * @export
 */
export const CodeReviewsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get the results of a code review using the review identifier for the task.  When you request a code review, the response includes a task result URL of the form: `/codereviews/{review-id}`.  This endpoint reports the results of a complete code review, or the status of a review  that\'s still in progress.
         * @summary Get results of code review
         * @param {string} reviewId The identifier for the review (from the &#x60;task-result-url&#x60;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeReview(reviewId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CodeReview>> {
            const localVarAxiosArgs = CodeReviewsApiAxiosParamCreator(configuration).getCodeReview(reviewId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Trigger the code review of a patch. This is available for projects with Git repositories.  Your request must include:    * Identifier for the base commit   * Patch generated using `git diff --binary` (see [git diff](https://git-scm.com/docs/git-diff))   * Header `Content-Type: application/octet-stream`   * For both LGTM.com and LGTM Enterprise, an access token with the `codereviews:write` scope  Note that if you make a request using Curl, you\'ll also need to add `--data-binary` to the request to ensure that the patch you supply in the body is sent with newlines unchanged. You can track the progress of the review using the task result URL returned on creation of the task, or by calling the `/operations` endpoint with the operations identifier returned by the request. For more information, see [Get operation status](https://lgtm.com/help/lgtm/api/api-v1#opIdgetOperation). Alternatively, if you supply a callback URL you\'ll get a post-back automatically on completion of the review.  When the review is complete, you can access the results using the task result URL.
         * @summary Run code review for a patch
         * @param {number} projectId The numeric project identifier.
         * @param {string} base The identifier for the base commit.
         * @param {number} externalId Your reference number for the code review.
         * @param {any} body The patch containing the code changes for review.
         * @param {string} [reviewUrl] An informative back-link to an external system.
         * @param {string} [callbackUrl] The callback URL for LGTM to post to on completion of the review. When the code review is complete, the API sends an HTTP POST request to the callback URL with the result of the code review in the request body. The code review results in the request body are identical to the results accessed through the [&#x60;/codereviews/{review-id}&#x60;](https://lgtm.com/help/lgtm/api/api-v1#opIdgetCodeReview) end-point. If you specify a &#x60;callback-secret&#x60;, the request also includes an &#x60;x-lgtm-signature&#x60; header with a digital signature of the request\&#39;s contents.
         * @param {string} [callbackSecret] The &#x60;callback-secret&#x60; is used to compute a signature which is included in the &#x60;x-lgtm-signature&#x60; header of the callback response. The receiver of the callback can check the validity of the response by computing the signature using HMAC-SHA1 and verifying that it matches the &#x60;x-lgtm-signature&#x60; header value. The HMAC algorithm requires byte sequences as inputs for both the secret and the message. The callback secret string must be converted to bytes using UTF-8 encoding. The response body should ideally be read as a plain byte sequence. Conversion to, for example a JSON object, and back to a byte sequence might change the formatting, and would invalidate the signature.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestReview(projectId: number, base: string, externalId: number, body: any, reviewUrl?: string, callbackUrl?: string, callbackSecret?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation> {
            const localVarAxiosArgs = CodeReviewsApiAxiosParamCreator(configuration).requestReview(projectId, base, externalId, body, reviewUrl, callbackUrl, callbackSecret, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CodeReviewsApi - factory interface
 * @export
 */
export const CodeReviewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get the results of a code review using the review identifier for the task.  When you request a code review, the response includes a task result URL of the form: `/codereviews/{review-id}`.  This endpoint reports the results of a complete code review, or the status of a review  that\'s still in progress.
         * @summary Get results of code review
         * @param {string} reviewId The identifier for the review (from the &#x60;task-result-url&#x60;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeReview(reviewId: string, options?: any) {
            return CodeReviewsApiFp(configuration).getCodeReview(reviewId, options)(axios, basePath);
        },
        /**
         * Trigger the code review of a patch. This is available for projects with Git repositories.  Your request must include:    * Identifier for the base commit   * Patch generated using `git diff --binary` (see [git diff](https://git-scm.com/docs/git-diff))   * Header `Content-Type: application/octet-stream`   * For both LGTM.com and LGTM Enterprise, an access token with the `codereviews:write` scope  Note that if you make a request using Curl, you\'ll also need to add `--data-binary` to the request to ensure that the patch you supply in the body is sent with newlines unchanged. You can track the progress of the review using the task result URL returned on creation of the task, or by calling the `/operations` endpoint with the operations identifier returned by the request. For more information, see [Get operation status](https://lgtm.com/help/lgtm/api/api-v1#opIdgetOperation). Alternatively, if you supply a callback URL you\'ll get a post-back automatically on completion of the review.  When the review is complete, you can access the results using the task result URL.
         * @summary Run code review for a patch
         * @param {number} projectId The numeric project identifier.
         * @param {string} base The identifier for the base commit.
         * @param {number} externalId Your reference number for the code review.
         * @param {any} body The patch containing the code changes for review.
         * @param {string} [reviewUrl] An informative back-link to an external system.
         * @param {string} [callbackUrl] The callback URL for LGTM to post to on completion of the review. When the code review is complete, the API sends an HTTP POST request to the callback URL with the result of the code review in the request body. The code review results in the request body are identical to the results accessed through the [&#x60;/codereviews/{review-id}&#x60;](https://lgtm.com/help/lgtm/api/api-v1#opIdgetCodeReview) end-point. If you specify a &#x60;callback-secret&#x60;, the request also includes an &#x60;x-lgtm-signature&#x60; header with a digital signature of the request\&#39;s contents.
         * @param {string} [callbackSecret] The &#x60;callback-secret&#x60; is used to compute a signature which is included in the &#x60;x-lgtm-signature&#x60; header of the callback response. The receiver of the callback can check the validity of the response by computing the signature using HMAC-SHA1 and verifying that it matches the &#x60;x-lgtm-signature&#x60; header value. The HMAC algorithm requires byte sequences as inputs for both the secret and the message. The callback secret string must be converted to bytes using UTF-8 encoding. The response body should ideally be read as a plain byte sequence. Conversion to, for example a JSON object, and back to a byte sequence might change the formatting, and would invalidate the signature.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestReview(projectId: number, base: string, externalId: number, body: any, reviewUrl?: string, callbackUrl?: string, callbackSecret?: string, options?: any) {
            return CodeReviewsApiFp(configuration).requestReview(projectId, base, externalId, body, reviewUrl, callbackUrl, callbackSecret, options)(axios, basePath);
        },
    };
};

/**
 * CodeReviewsApi - object-oriented interface
 * @export
 * @class CodeReviewsApi
 * @extends {BaseAPI}
 */
export class CodeReviewsApi extends BaseAPI {
    /**
     * Get the results of a code review using the review identifier for the task.  When you request a code review, the response includes a task result URL of the form: `/codereviews/{review-id}`.  This endpoint reports the results of a complete code review, or the status of a review  that\'s still in progress.
     * @summary Get results of code review
     * @param {string} reviewId The identifier for the review (from the &#x60;task-result-url&#x60;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReviewsApi
     */
    public getCodeReview(reviewId: string, options?: any) {
        return CodeReviewsApiFp(this.configuration).getCodeReview(reviewId, options)(this.axios, this.basePath);
    }

    /**
     * Trigger the code review of a patch. This is available for projects with Git repositories.  Your request must include:    * Identifier for the base commit   * Patch generated using `git diff --binary` (see [git diff](https://git-scm.com/docs/git-diff))   * Header `Content-Type: application/octet-stream`   * For both LGTM.com and LGTM Enterprise, an access token with the `codereviews:write` scope  Note that if you make a request using Curl, you\'ll also need to add `--data-binary` to the request to ensure that the patch you supply in the body is sent with newlines unchanged. You can track the progress of the review using the task result URL returned on creation of the task, or by calling the `/operations` endpoint with the operations identifier returned by the request. For more information, see [Get operation status](https://lgtm.com/help/lgtm/api/api-v1#opIdgetOperation). Alternatively, if you supply a callback URL you\'ll get a post-back automatically on completion of the review.  When the review is complete, you can access the results using the task result URL.
     * @summary Run code review for a patch
     * @param {number} projectId The numeric project identifier.
     * @param {string} base The identifier for the base commit.
     * @param {number} externalId Your reference number for the code review.
     * @param {any} body The patch containing the code changes for review.
     * @param {string} [reviewUrl] An informative back-link to an external system.
     * @param {string} [callbackUrl] The callback URL for LGTM to post to on completion of the review. When the code review is complete, the API sends an HTTP POST request to the callback URL with the result of the code review in the request body. The code review results in the request body are identical to the results accessed through the [&#x60;/codereviews/{review-id}&#x60;](https://lgtm.com/help/lgtm/api/api-v1#opIdgetCodeReview) end-point. If you specify a &#x60;callback-secret&#x60;, the request also includes an &#x60;x-lgtm-signature&#x60; header with a digital signature of the request\&#39;s contents.
     * @param {string} [callbackSecret] The &#x60;callback-secret&#x60; is used to compute a signature which is included in the &#x60;x-lgtm-signature&#x60; header of the callback response. The receiver of the callback can check the validity of the response by computing the signature using HMAC-SHA1 and verifying that it matches the &#x60;x-lgtm-signature&#x60; header value. The HMAC algorithm requires byte sequences as inputs for both the secret and the message. The callback secret string must be converted to bytes using UTF-8 encoding. The response body should ideally be read as a plain byte sequence. Conversion to, for example a JSON object, and back to a byte sequence might change the formatting, and would invalidate the signature.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReviewsApi
     */
    public requestReview(projectId: number, base: string, externalId: number, body: any, reviewUrl?: string, callbackUrl?: string, callbackSecret?: string, options?: any) {
        return CodeReviewsApiFp(this.configuration).requestReview(projectId, base, externalId, body, reviewUrl, callbackUrl, callbackSecret, options)(this.axios, this.basePath);
    }

}


/**
 * OperationsApi - axios parameter creator
 * @export
 */
export const OperationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Track progress of a long-running operation using the operations identifier returned when you  created the operation. For example, by triggering the analysis of a commit, or the code review of a patch. For both LGTM.com and LGTM Enterprise, you must include an access token with the `operations:read` scope.
         * @summary Get operation status
         * @param {number} operationId The operation identifier returned on creating the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperation(operationId: number, options: any = {}): RequestArgs {
            // verify required parameter 'operationId' is not null or undefined
            if (operationId === null || operationId === undefined) {
                throw new RequiredError('operationId','Required parameter operationId was null or undefined when calling getOperation.');
            }
            const localVarPath = `/operations/{operation-id}`
                .replace(`{${"operation-id"}}`, encodeURIComponent(String(operationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperationsApi - functional programming interface
 * @export
 */
export const OperationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Track progress of a long-running operation using the operations identifier returned when you  created the operation. For example, by triggering the analysis of a commit, or the code review of a patch. For both LGTM.com and LGTM Enterprise, you must include an access token with the `operations:read` scope.
         * @summary Get operation status
         * @param {number} operationId The operation identifier returned on creating the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperation(operationId: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation> {
            const localVarAxiosArgs = OperationsApiAxiosParamCreator(configuration).getOperation(operationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OperationsApi - factory interface
 * @export
 */
export const OperationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Track progress of a long-running operation using the operations identifier returned when you  created the operation. For example, by triggering the analysis of a commit, or the code review of a patch. For both LGTM.com and LGTM Enterprise, you must include an access token with the `operations:read` scope.
         * @summary Get operation status
         * @param {number} operationId The operation identifier returned on creating the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperation(operationId: number, options?: any) {
            return OperationsApiFp(configuration).getOperation(operationId, options)(axios, basePath);
        },
    };
};

/**
 * OperationsApi - object-oriented interface
 * @export
 * @class OperationsApi
 * @extends {BaseAPI}
 */
export class OperationsApi extends BaseAPI {
    /**
     * Track progress of a long-running operation using the operations identifier returned when you  created the operation. For example, by triggering the analysis of a commit, or the code review of a patch. For both LGTM.com and LGTM Enterprise, you must include an access token with the `operations:read` scope.
     * @summary Get operation status
     * @param {number} operationId The operation identifier returned on creating the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public getOperation(operationId: number, options?: any) {
        return OperationsApiFp(this.configuration).getOperation(operationId, options)(this.axios, this.basePath);
    }

}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * LGTM administrators can add a new project to LGTM by providing a repository URL. By default, LGTM tries to build and analyze the project in the same way as for projects added through the user interface. If at least one language is successfully analyzed, and the repository doesn\'t already exist on LGTM, a new project is created. If the project already exists but your API call triggers a successful analysis  of additional languages, LGTM adds those languages to the project.  You can configure how LGTM processes the project using query parameters to:   * Specify the languages to analyze.   * Create a new project in [sparse mode](https://help.semmle.com/lgtm-enterprise/user/help/analysis-faqs.html#what-is-sparse-analysis).   * Create a new project in [upload mode](https://help.semmle.com/lgtm-enterprise/user/help/analysis-faqs.html#what-is-upload-analysis) to analyze externally-generated databases. Each database represents a snapshot of the codebase.    Use this option when you want to upload databases that were generated by the CodeQL CLI (or the QL command-line tools).   The version of the command line used to generate the database   must be the same version as LGTM Enterprise.   With any of these options, you can also include an `lgtm.yml` in the body of the request to [customize extraction](https://lgtm.com/help/lgtm/customizing-code-extraction).
         * @summary Add a project to LGTM
         * @param {string} repository The URL of the repository to analyze. LGTM tests this against the [repository providers](https://lgtm.com/admin/help/adding-repository-providers) defined for the system. If it doesn\&#39;t match any of them, the request fails.
         * @param {Array<string>} [language] Optional, a [language code](https://lgtm.com/help/lgtm/analysis-faqs#which-languages-are-supported) to specify which language to analyze. To request the analysis of more than one language, specify a query parameter for each language. By default, LGTM tries to analyze all supported languages.
         * @param {'full' | 'sparse' | 'upload'} [mode] The analysis mode of the new project. When set to &#x60;full&#x60; all commits of the project are analyzed; when set to &#x60;sparse&#x60; the latest commit of the project is analyzed periodically; when set to &#x60;upload&#x60;,  no automatic analysis is performed, instead externally-generated databases should be uploaded. For new projects the default value is &#x60;full&#x60;. The &#x60;mode&#x60; parameter cannot be used to change the analysis mode of existing projects. Therefore, for existing projects, it should either be left blank or set to match the analysis mode of the project.
         * @param {string} [commit] Required when &#x60;mode&#x3D;upload&#x60;, specify the identifier of the commit used to generate the database.
         * @param {Date} [date] Optional when &#x60;mode&#x3D;upload&#x60;, specify the date and time of the commit used to generate the database; defaults to the current time.
         * @param {Array<string>} [workerLabel] Optional, any [labels](https://lgtm.com/admin/help/defining-worker-labels) required by workers to analyze this project.  To specify more than one label, repeat the query parameter.
         * @param {string} [body] An optional [lgtm.yml project configuration](https://lgtm.com/help/lgtm/lgtm.yml-configuration-file) file to customize the LGTM code analysis and results display for the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProject(repository: string, language?: Array<string>, mode?: 'full' | 'sparse' | 'upload', commit?: string, date?: Date, workerLabel?: Array<string>, body?: string, options: any = {}): RequestArgs {
            // verify required parameter 'repository' is not null or undefined
            if (repository === null || repository === undefined) {
                throw new RequiredError('repository','Required parameter repository was null or undefined when calling addProject.');
            }
            const localVarPath = `/projects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (repository !== undefined) {
                localVarQueryParameter['repository'] = repository;
            }

            if (language) {
                localVarQueryParameter['language'] = language;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (commit !== undefined) {
                localVarQueryParameter['commit'] = commit;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any).toISOString();
            }

            if (workerLabel) {
                localVarQueryParameter['worker-label'] = workerLabel;
            }



            localVarHeaderParameter['Content-Type'] = 'application/x-yaml';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the latest summary for a specific project using the numeric project identifier.  To find the LGTM identifier for a project, list all projects using the `/projects`  endpoint and look up the project by name. Alternatively, use the `/projects/{provider}/{org}/{name}` endpoint. If you have administration access, the project identifier is also displayed in  the administration page for the project.
         * @summary Get project by numeric identifier
         * @param {number} projectId The numeric project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectId: number, options: any = {}): RequestArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling getProject.');
            }
            const localVarPath = `/projects/{project-id}`
                .replace(`{${"project-id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the latest summary for a specific project using the project\'s URL identifier `{provider}/{org}/{name}`.  To find the URL identifier for a project, view the project overview page in LGTM. The URL identifier follows after `/projects`. For example, for a project with the URL `https://lgtm.example.com/projects/g/apache/commons-io` the URL identifier is `g/apache/commons-io`. In the example, `g` represents the `provider` (repository host), `apache` is the `organization` and `commons-io` is the `name` of the repository.
         * @summary Get project by URL identifier
         * @param {string} provider The first part of the URL identifier of a project, which represents the repository host.
         * @param {string} org The second part of the URL identifier of a project, the organization.
         * @param {string} name The third part of the URL identifier of a project, the repository name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectByUrlIdentifier(provider: string, org: string, name: string, options: any = {}): RequestArgs {
            // verify required parameter 'provider' is not null or undefined
            if (provider === null || provider === undefined) {
                throw new RequiredError('provider','Required parameter provider was null or undefined when calling getProjectByUrlIdentifier.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling getProjectByUrlIdentifier.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getProjectByUrlIdentifier.');
            }
            const localVarPath = `/projects/{provider}/{org}/{name}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the latest configuration for a specific project using the numeric project identifier.
         * @summary Get configuration for a project identified by numeric identifier
         * @param {number} projectId The numeric project identifier
         * @param {'repository' | 'administrator'} [source] The type of project configuration to retrieve. If this parameter isn\&#39;t specified, the request retrieves the effective configuration. That is, the configuration that is actually applied to the project, which may be from: * the repository * the administrator-set, project configuration * the global configuration.  If you do specify this value, it must be one of:   * &#x60;repository&#x60; to retrieve the configuration specified by a YAML file in the repository. A 404 status is returned if there is no repository configuration.    * &#x60;administrator&#x60; to retrieve the administrator-set, project configuration. A 404 status is returned if there is no administrator configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectConfig(projectId: number, source?: 'repository' | 'administrator', options: any = {}): RequestArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling getProjectConfig.');
            }
            const localVarPath = `/projects/{project-id}/settings/analysis-configuration`
                .replace(`{${"project-id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the projects the current user has authorization to view.   A maximum of 100 projects are returned in each response. When further results are available, the response includes the URL you need to request the next page of results.  Use the optional parameter, `limit`, to change the number of results reported in each response (range of 1&mdash;100). If you supply an invalid value for this  parameter, the default value of 100 is used.  When more than one page of results is available, each response includes a `nextPageUrl` response parameter. You can use this URL to request the next page of results. The `nextPageUrl` includes an automatically generated `start` parameter, which specifies the projects to return in the next page of results.
         * @summary List projects
         * @param {number} [limit] The maximum number of projects to return in each response (1-100).
         * @param {string} [start] An opaque identifier generated by the API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects(limit?: number, start?: string, options: any = {}): RequestArgs {
            const localVarPath = `/projects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * LGTM administrators can add a new project to LGTM by providing a repository URL. By default, LGTM tries to build and analyze the project in the same way as for projects added through the user interface. If at least one language is successfully analyzed, and the repository doesn\'t already exist on LGTM, a new project is created. If the project already exists but your API call triggers a successful analysis  of additional languages, LGTM adds those languages to the project.  You can configure how LGTM processes the project using query parameters to:   * Specify the languages to analyze.   * Create a new project in [sparse mode](https://help.semmle.com/lgtm-enterprise/user/help/analysis-faqs.html#what-is-sparse-analysis).   * Create a new project in [upload mode](https://help.semmle.com/lgtm-enterprise/user/help/analysis-faqs.html#what-is-upload-analysis) to analyze externally-generated databases. Each database represents a snapshot of the codebase.    Use this option when you want to upload databases that were generated by the CodeQL CLI (or the QL command-line tools).   The version of the command line used to generate the database   must be the same version as LGTM Enterprise.   With any of these options, you can also include an `lgtm.yml` in the body of the request to [customize extraction](https://lgtm.com/help/lgtm/customizing-code-extraction).
         * @summary Add a project to LGTM
         * @param {string} repository The URL of the repository to analyze. LGTM tests this against the [repository providers](https://lgtm.com/admin/help/adding-repository-providers) defined for the system. If it doesn\&#39;t match any of them, the request fails.
         * @param {Array<string>} [language] Optional, a [language code](https://lgtm.com/help/lgtm/analysis-faqs#which-languages-are-supported) to specify which language to analyze. To request the analysis of more than one language, specify a query parameter for each language. By default, LGTM tries to analyze all supported languages.
         * @param {'full' | 'sparse' | 'upload'} [mode] The analysis mode of the new project. When set to &#x60;full&#x60; all commits of the project are analyzed; when set to &#x60;sparse&#x60; the latest commit of the project is analyzed periodically; when set to &#x60;upload&#x60;,  no automatic analysis is performed, instead externally-generated databases should be uploaded. For new projects the default value is &#x60;full&#x60;. The &#x60;mode&#x60; parameter cannot be used to change the analysis mode of existing projects. Therefore, for existing projects, it should either be left blank or set to match the analysis mode of the project.
         * @param {string} [commit] Required when &#x60;mode&#x3D;upload&#x60;, specify the identifier of the commit used to generate the database.
         * @param {Date} [date] Optional when &#x60;mode&#x3D;upload&#x60;, specify the date and time of the commit used to generate the database; defaults to the current time.
         * @param {Array<string>} [workerLabel] Optional, any [labels](https://lgtm.com/admin/help/defining-worker-labels) required by workers to analyze this project.  To specify more than one label, repeat the query parameter.
         * @param {string} [body] An optional [lgtm.yml project configuration](https://lgtm.com/help/lgtm/lgtm.yml-configuration-file) file to customize the LGTM code analysis and results display for the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProject(repository: string, language?: Array<string>, mode?: 'full' | 'sparse' | 'upload', commit?: string, date?: Date, workerLabel?: Array<string>, body?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).addProject(repository, language, mode, commit, date, workerLabel, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the latest summary for a specific project using the numeric project identifier.  To find the LGTM identifier for a project, list all projects using the `/projects`  endpoint and look up the project by name. Alternatively, use the `/projects/{provider}/{org}/{name}` endpoint. If you have administration access, the project identifier is also displayed in  the administration page for the project.
         * @summary Get project by numeric identifier
         * @param {number} projectId The numeric project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectId: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDetails> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).getProject(projectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the latest summary for a specific project using the project\'s URL identifier `{provider}/{org}/{name}`.  To find the URL identifier for a project, view the project overview page in LGTM. The URL identifier follows after `/projects`. For example, for a project with the URL `https://lgtm.example.com/projects/g/apache/commons-io` the URL identifier is `g/apache/commons-io`. In the example, `g` represents the `provider` (repository host), `apache` is the `organization` and `commons-io` is the `name` of the repository.
         * @summary Get project by URL identifier
         * @param {string} provider The first part of the URL identifier of a project, which represents the repository host.
         * @param {string} org The second part of the URL identifier of a project, the organization.
         * @param {string} name The third part of the URL identifier of a project, the repository name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectByUrlIdentifier(provider: string, org: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDetails> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).getProjectByUrlIdentifier(provider, org, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the latest configuration for a specific project using the numeric project identifier.
         * @summary Get configuration for a project identified by numeric identifier
         * @param {number} projectId The numeric project identifier
         * @param {'repository' | 'administrator'} [source] The type of project configuration to retrieve. If this parameter isn\&#39;t specified, the request retrieves the effective configuration. That is, the configuration that is actually applied to the project, which may be from: * the repository * the administrator-set, project configuration * the global configuration.  If you do specify this value, it must be one of:   * &#x60;repository&#x60; to retrieve the configuration specified by a YAML file in the repository. A 404 status is returned if there is no repository configuration.    * &#x60;administrator&#x60; to retrieve the administrator-set, project configuration. A 404 status is returned if there is no administrator configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectConfig(projectId: number, source?: 'repository' | 'administrator', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).getProjectConfig(projectId, source, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all the projects the current user has authorization to view.   A maximum of 100 projects are returned in each response. When further results are available, the response includes the URL you need to request the next page of results.  Use the optional parameter, `limit`, to change the number of results reported in each response (range of 1&mdash;100). If you supply an invalid value for this  parameter, the default value of 100 is used.  When more than one page of results is available, each response includes a `nextPageUrl` response parameter. You can use this URL to request the next page of results. The `nextPageUrl` includes an automatically generated `start` parameter, which specifies the projects to return in the next page of results.
         * @summary List projects
         * @param {number} [limit] The maximum number of projects to return in each response (1-100).
         * @param {string} [start] An opaque identifier generated by the API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects(limit?: number, start?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectList> {
            const localVarAxiosArgs = ProjectsApiAxiosParamCreator(configuration).getProjects(limit, start, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * LGTM administrators can add a new project to LGTM by providing a repository URL. By default, LGTM tries to build and analyze the project in the same way as for projects added through the user interface. If at least one language is successfully analyzed, and the repository doesn\'t already exist on LGTM, a new project is created. If the project already exists but your API call triggers a successful analysis  of additional languages, LGTM adds those languages to the project.  You can configure how LGTM processes the project using query parameters to:   * Specify the languages to analyze.   * Create a new project in [sparse mode](https://help.semmle.com/lgtm-enterprise/user/help/analysis-faqs.html#what-is-sparse-analysis).   * Create a new project in [upload mode](https://help.semmle.com/lgtm-enterprise/user/help/analysis-faqs.html#what-is-upload-analysis) to analyze externally-generated databases. Each database represents a snapshot of the codebase.    Use this option when you want to upload databases that were generated by the CodeQL CLI (or the QL command-line tools).   The version of the command line used to generate the database   must be the same version as LGTM Enterprise.   With any of these options, you can also include an `lgtm.yml` in the body of the request to [customize extraction](https://lgtm.com/help/lgtm/customizing-code-extraction).
         * @summary Add a project to LGTM
         * @param {string} repository The URL of the repository to analyze. LGTM tests this against the [repository providers](https://lgtm.com/admin/help/adding-repository-providers) defined for the system. If it doesn\&#39;t match any of them, the request fails.
         * @param {Array<string>} [language] Optional, a [language code](https://lgtm.com/help/lgtm/analysis-faqs#which-languages-are-supported) to specify which language to analyze. To request the analysis of more than one language, specify a query parameter for each language. By default, LGTM tries to analyze all supported languages.
         * @param {'full' | 'sparse' | 'upload'} [mode] The analysis mode of the new project. When set to &#x60;full&#x60; all commits of the project are analyzed; when set to &#x60;sparse&#x60; the latest commit of the project is analyzed periodically; when set to &#x60;upload&#x60;,  no automatic analysis is performed, instead externally-generated databases should be uploaded. For new projects the default value is &#x60;full&#x60;. The &#x60;mode&#x60; parameter cannot be used to change the analysis mode of existing projects. Therefore, for existing projects, it should either be left blank or set to match the analysis mode of the project.
         * @param {string} [commit] Required when &#x60;mode&#x3D;upload&#x60;, specify the identifier of the commit used to generate the database.
         * @param {Date} [date] Optional when &#x60;mode&#x3D;upload&#x60;, specify the date and time of the commit used to generate the database; defaults to the current time.
         * @param {Array<string>} [workerLabel] Optional, any [labels](https://lgtm.com/admin/help/defining-worker-labels) required by workers to analyze this project.  To specify more than one label, repeat the query parameter.
         * @param {string} [body] An optional [lgtm.yml project configuration](https://lgtm.com/help/lgtm/lgtm.yml-configuration-file) file to customize the LGTM code analysis and results display for the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProject(repository: string, language?: Array<string>, mode?: 'full' | 'sparse' | 'upload', commit?: string, date?: Date, workerLabel?: Array<string>, body?: string, options?: any) {
            return ProjectsApiFp(configuration).addProject(repository, language, mode, commit, date, workerLabel, body, options)(axios, basePath);
        },
        /**
         * Get the latest summary for a specific project using the numeric project identifier.  To find the LGTM identifier for a project, list all projects using the `/projects`  endpoint and look up the project by name. Alternatively, use the `/projects/{provider}/{org}/{name}` endpoint. If you have administration access, the project identifier is also displayed in  the administration page for the project.
         * @summary Get project by numeric identifier
         * @param {number} projectId The numeric project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectId: number, options?: any) {
            return ProjectsApiFp(configuration).getProject(projectId, options)(axios, basePath);
        },
        /**
         * Get the latest summary for a specific project using the project\'s URL identifier `{provider}/{org}/{name}`.  To find the URL identifier for a project, view the project overview page in LGTM. The URL identifier follows after `/projects`. For example, for a project with the URL `https://lgtm.example.com/projects/g/apache/commons-io` the URL identifier is `g/apache/commons-io`. In the example, `g` represents the `provider` (repository host), `apache` is the `organization` and `commons-io` is the `name` of the repository.
         * @summary Get project by URL identifier
         * @param {string} provider The first part of the URL identifier of a project, which represents the repository host.
         * @param {string} org The second part of the URL identifier of a project, the organization.
         * @param {string} name The third part of the URL identifier of a project, the repository name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectByUrlIdentifier(provider: string, org: string, name: string, options?: any) {
            return ProjectsApiFp(configuration).getProjectByUrlIdentifier(provider, org, name, options)(axios, basePath);
        },
        /**
         * Get the latest configuration for a specific project using the numeric project identifier.
         * @summary Get configuration for a project identified by numeric identifier
         * @param {number} projectId The numeric project identifier
         * @param {'repository' | 'administrator'} [source] The type of project configuration to retrieve. If this parameter isn\&#39;t specified, the request retrieves the effective configuration. That is, the configuration that is actually applied to the project, which may be from: * the repository * the administrator-set, project configuration * the global configuration.  If you do specify this value, it must be one of:   * &#x60;repository&#x60; to retrieve the configuration specified by a YAML file in the repository. A 404 status is returned if there is no repository configuration.    * &#x60;administrator&#x60; to retrieve the administrator-set, project configuration. A 404 status is returned if there is no administrator configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectConfig(projectId: number, source?: 'repository' | 'administrator', options?: any) {
            return ProjectsApiFp(configuration).getProjectConfig(projectId, source, options)(axios, basePath);
        },
        /**
         * List all the projects the current user has authorization to view.   A maximum of 100 projects are returned in each response. When further results are available, the response includes the URL you need to request the next page of results.  Use the optional parameter, `limit`, to change the number of results reported in each response (range of 1&mdash;100). If you supply an invalid value for this  parameter, the default value of 100 is used.  When more than one page of results is available, each response includes a `nextPageUrl` response parameter. You can use this URL to request the next page of results. The `nextPageUrl` includes an automatically generated `start` parameter, which specifies the projects to return in the next page of results.
         * @summary List projects
         * @param {number} [limit] The maximum number of projects to return in each response (1-100).
         * @param {string} [start] An opaque identifier generated by the API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects(limit?: number, start?: string, options?: any) {
            return ProjectsApiFp(configuration).getProjects(limit, start, options)(axios, basePath);
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * LGTM administrators can add a new project to LGTM by providing a repository URL. By default, LGTM tries to build and analyze the project in the same way as for projects added through the user interface. If at least one language is successfully analyzed, and the repository doesn\'t already exist on LGTM, a new project is created. If the project already exists but your API call triggers a successful analysis  of additional languages, LGTM adds those languages to the project.  You can configure how LGTM processes the project using query parameters to:   * Specify the languages to analyze.   * Create a new project in [sparse mode](https://help.semmle.com/lgtm-enterprise/user/help/analysis-faqs.html#what-is-sparse-analysis).   * Create a new project in [upload mode](https://help.semmle.com/lgtm-enterprise/user/help/analysis-faqs.html#what-is-upload-analysis) to analyze externally-generated databases. Each database represents a snapshot of the codebase.    Use this option when you want to upload databases that were generated by the CodeQL CLI (or the QL command-line tools).   The version of the command line used to generate the database   must be the same version as LGTM Enterprise.   With any of these options, you can also include an `lgtm.yml` in the body of the request to [customize extraction](https://lgtm.com/help/lgtm/customizing-code-extraction).
     * @summary Add a project to LGTM
     * @param {string} repository The URL of the repository to analyze. LGTM tests this against the [repository providers](https://lgtm.com/admin/help/adding-repository-providers) defined for the system. If it doesn\&#39;t match any of them, the request fails.
     * @param {Array<string>} [language] Optional, a [language code](https://lgtm.com/help/lgtm/analysis-faqs#which-languages-are-supported) to specify which language to analyze. To request the analysis of more than one language, specify a query parameter for each language. By default, LGTM tries to analyze all supported languages.
     * @param {'full' | 'sparse' | 'upload'} [mode] The analysis mode of the new project. When set to &#x60;full&#x60; all commits of the project are analyzed; when set to &#x60;sparse&#x60; the latest commit of the project is analyzed periodically; when set to &#x60;upload&#x60;,  no automatic analysis is performed, instead externally-generated databases should be uploaded. For new projects the default value is &#x60;full&#x60;. The &#x60;mode&#x60; parameter cannot be used to change the analysis mode of existing projects. Therefore, for existing projects, it should either be left blank or set to match the analysis mode of the project.
     * @param {string} [commit] Required when &#x60;mode&#x3D;upload&#x60;, specify the identifier of the commit used to generate the database.
     * @param {Date} [date] Optional when &#x60;mode&#x3D;upload&#x60;, specify the date and time of the commit used to generate the database; defaults to the current time.
     * @param {Array<string>} [workerLabel] Optional, any [labels](https://lgtm.com/admin/help/defining-worker-labels) required by workers to analyze this project.  To specify more than one label, repeat the query parameter.
     * @param {string} [body] An optional [lgtm.yml project configuration](https://lgtm.com/help/lgtm/lgtm.yml-configuration-file) file to customize the LGTM code analysis and results display for the project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public addProject(repository: string, language?: Array<string>, mode?: 'full' | 'sparse' | 'upload', commit?: string, date?: Date, workerLabel?: Array<string>, body?: string, options?: any) {
        return ProjectsApiFp(this.configuration).addProject(repository, language, mode, commit, date, workerLabel, body, options)(this.axios, this.basePath);
    }

    /**
     * Get the latest summary for a specific project using the numeric project identifier.  To find the LGTM identifier for a project, list all projects using the `/projects`  endpoint and look up the project by name. Alternatively, use the `/projects/{provider}/{org}/{name}` endpoint. If you have administration access, the project identifier is also displayed in  the administration page for the project.
     * @summary Get project by numeric identifier
     * @param {number} projectId The numeric project identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProject(projectId: number, options?: any) {
        return ProjectsApiFp(this.configuration).getProject(projectId, options)(this.axios, this.basePath);
    }

    /**
     * Get the latest summary for a specific project using the project\'s URL identifier `{provider}/{org}/{name}`.  To find the URL identifier for a project, view the project overview page in LGTM. The URL identifier follows after `/projects`. For example, for a project with the URL `https://lgtm.example.com/projects/g/apache/commons-io` the URL identifier is `g/apache/commons-io`. In the example, `g` represents the `provider` (repository host), `apache` is the `organization` and `commons-io` is the `name` of the repository.
     * @summary Get project by URL identifier
     * @param {string} provider The first part of the URL identifier of a project, which represents the repository host.
     * @param {string} org The second part of the URL identifier of a project, the organization.
     * @param {string} name The third part of the URL identifier of a project, the repository name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectByUrlIdentifier(provider: string, org: string, name: string, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectByUrlIdentifier(provider, org, name, options)(this.axios, this.basePath);
    }

    /**
     * Get the latest configuration for a specific project using the numeric project identifier.
     * @summary Get configuration for a project identified by numeric identifier
     * @param {number} projectId The numeric project identifier
     * @param {'repository' | 'administrator'} [source] The type of project configuration to retrieve. If this parameter isn\&#39;t specified, the request retrieves the effective configuration. That is, the configuration that is actually applied to the project, which may be from: * the repository * the administrator-set, project configuration * the global configuration.  If you do specify this value, it must be one of:   * &#x60;repository&#x60; to retrieve the configuration specified by a YAML file in the repository. A 404 status is returned if there is no repository configuration.    * &#x60;administrator&#x60; to retrieve the administrator-set, project configuration. A 404 status is returned if there is no administrator configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectConfig(projectId: number, source?: 'repository' | 'administrator', options?: any) {
        return ProjectsApiFp(this.configuration).getProjectConfig(projectId, source, options)(this.axios, this.basePath);
    }

    /**
     * List all the projects the current user has authorization to view.   A maximum of 100 projects are returned in each response. When further results are available, the response includes the URL you need to request the next page of results.  Use the optional parameter, `limit`, to change the number of results reported in each response (range of 1&mdash;100). If you supply an invalid value for this  parameter, the default value of 100 is used.  When more than one page of results is available, each response includes a `nextPageUrl` response parameter. You can use this URL to request the next page of results. The `nextPageUrl` includes an automatically generated `start` parameter, which specifies the projects to return in the next page of results.
     * @summary List projects
     * @param {number} [limit] The maximum number of projects to return in each response (1-100).
     * @param {string} [start] An opaque identifier generated by the API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjects(limit?: number, start?: string, options?: any) {
        return ProjectsApiFp(this.configuration).getProjects(limit, start, options)(this.axios, this.basePath);
    }

}


/**
 * QueryJobsApi - axios parameter creator
 * @export
 */
export const QueryJobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submit a query to run on one or more projects on LGTM. The query is included in the body of the request.
         * @summary Run a CodeQL query on one or more projects
         * @param {string} language The [language](https://lgtm.com/help/lgtm/analysis-faqs#which-languages-are-supported) you want to analyze.
         * @param {string} body The query to run.
         * @param {Array<number>} [projectId] The identifier of the project to analyze. Either &#x60;project-id&#x60; or &#x60;projects-list&#x60; must be specified.
         * @param {string} [projectsList] Name of the list containing the projects to analyze. Either &#x60;project-id&#x60; or &#x60;projects-list&#x60; must be specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryJob(language: string, body: string, projectId?: Array<number>, projectsList?: string, options: any = {}): RequestArgs {
            // verify required parameter 'language' is not null or undefined
            if (language === null || language === undefined) {
                throw new RequiredError('language','Required parameter language was null or undefined when calling createQueryJob.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createQueryJob.');
            }
            const localVarPath = `/queryjobs`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (projectId) {
                localVarQueryParameter['project-id'] = projectId;
            }

            if (projectsList !== undefined) {
                localVarQueryParameter['projects-list'] = projectsList;
            }



            localVarHeaderParameter['Content-Type'] = 'text/plain';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status of a query job using the query job identifier for the task.  When you create a query job, the response includes a task result URL of the form: `/queryjobs/{queryjob-id}`.
         * @summary Get the status of a query job
         * @param {string} queryjobId The identifier of the query job, from the &#x60;task-result&#x60; given in the response to the initial &#x60;POST /queryjobs&#x60; request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryJob(queryjobId: string, options: any = {}): RequestArgs {
            // verify required parameter 'queryjobId' is not null or undefined
            if (queryjobId === null || queryjobId === undefined) {
                throw new RequiredError('queryjobId','Required parameter queryjobId was null or undefined when calling getQueryJob.');
            }
            const localVarPath = `/queryjobs/{queryjob-id}`
                .replace(`{${"queryjob-id"}}`, encodeURIComponent(String(queryjobId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the results for a specific project. The endpoint succeeds only if the query was successful,  and returns a `404` error otherwise.  By default, the endpoint provides only results that are within the source tree. To obtain all results, specify the `nofilter` parameter.
         * @summary Fetch the results of a query job for a specific project
         * @param {string} queryjobId The identifier of the query job, from the &#x60;task-result&#x60; given in the response to the initial &#x60;POST /queryjobs&#x60; request.
         * @param {string} projectId The identifier for the project.
         * @param {number} [start] Start point for the page of results.
         * @param {number} [limit] The maximum number of results to display (less than 100).
         * @param {boolean} [nofilter] Include results that are not part of the source tree. These results are filtered out by default.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryJobResultsForProject(queryjobId: string, projectId: string, start?: number, limit?: number, nofilter?: boolean, options: any = {}): RequestArgs {
            // verify required parameter 'queryjobId' is not null or undefined
            if (queryjobId === null || queryjobId === undefined) {
                throw new RequiredError('queryjobId','Required parameter queryjobId was null or undefined when calling getQueryJobResultsForProject.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling getQueryJobResultsForProject.');
            }
            const localVarPath = `/queryjobs/{queryjob-id}/results/{project-id}`
                .replace(`{${"queryjob-id"}}`, encodeURIComponent(String(queryjobId)))
                .replace(`{${"project-id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (nofilter !== undefined) {
                localVarQueryParameter['nofilter'] = nofilter;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint provides a summary of the results generated by completed query runs for each  project specified in the the POST /queryjobs endpoint.  For completed query jobs, the summary includes:    * The number of results for successful query runs.   * Error information for failed query runs.  No information is included in the response for any project for which the query  run is still in progress.
         * @summary Provide a summary of results for the projects in the query job
         * @param {string} queryjobId The identifier of the query job, from the &#x60;task-result&#x60; given in the response to the initial &#x60;POST /queryjobs&#x60; request.
         * @param {string} [start] An opaque identifier generated by the API used for pagination.  This identifier will be included as part of the response for this endpoint whenever more than one page of results is available.
         * @param {number} [limit] The number of results to return. Useful for pagination.
         * @param {string} [filter] Only return a subset of results. Legal values are &#x60;w-results&#x60;, &#x60;wo-results&#x60;, &#x60;error&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryJobResultsOverview(queryjobId: string, start?: string, limit?: number, filter?: string, options: any = {}): RequestArgs {
            // verify required parameter 'queryjobId' is not null or undefined
            if (queryjobId === null || queryjobId === undefined) {
                throw new RequiredError('queryjobId','Required parameter queryjobId was null or undefined when calling getQueryJobResultsOverview.');
            }
            const localVarPath = `/queryjobs/{queryjob-id}/results`
                .replace(`{${"queryjob-id"}}`, encodeURIComponent(String(queryjobId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryJobsApi - functional programming interface
 * @export
 */
export const QueryJobsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Submit a query to run on one or more projects on LGTM. The query is included in the body of the request.
         * @summary Run a CodeQL query on one or more projects
         * @param {string} language The [language](https://lgtm.com/help/lgtm/analysis-faqs#which-languages-are-supported) you want to analyze.
         * @param {string} body The query to run.
         * @param {Array<number>} [projectId] The identifier of the project to analyze. Either &#x60;project-id&#x60; or &#x60;projects-list&#x60; must be specified.
         * @param {string} [projectsList] Name of the list containing the projects to analyze. Either &#x60;project-id&#x60; or &#x60;projects-list&#x60; must be specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryJob(language: string, body: string, projectId?: Array<number>, projectsList?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation> {
            const localVarAxiosArgs = QueryJobsApiAxiosParamCreator(configuration).createQueryJob(language, body, projectId, projectsList, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the status of a query job using the query job identifier for the task.  When you create a query job, the response includes a task result URL of the form: `/queryjobs/{queryjob-id}`.
         * @summary Get the status of a query job
         * @param {string} queryjobId The identifier of the query job, from the &#x60;task-result&#x60; given in the response to the initial &#x60;POST /queryjobs&#x60; request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryJob(queryjobId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Queryjob> {
            const localVarAxiosArgs = QueryJobsApiAxiosParamCreator(configuration).getQueryJob(queryjobId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch the results for a specific project. The endpoint succeeds only if the query was successful,  and returns a `404` error otherwise.  By default, the endpoint provides only results that are within the source tree. To obtain all results, specify the `nofilter` parameter.
         * @summary Fetch the results of a query job for a specific project
         * @param {string} queryjobId The identifier of the query job, from the &#x60;task-result&#x60; given in the response to the initial &#x60;POST /queryjobs&#x60; request.
         * @param {string} projectId The identifier for the project.
         * @param {number} [start] Start point for the page of results.
         * @param {number} [limit] The maximum number of results to display (less than 100).
         * @param {boolean} [nofilter] Include results that are not part of the source tree. These results are filtered out by default.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryJobResultsForProject(queryjobId: string, projectId: string, start?: number, limit?: number, nofilter?: boolean, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryjobProjectResults> {
            const localVarAxiosArgs = QueryJobsApiAxiosParamCreator(configuration).getQueryJobResultsForProject(queryjobId, projectId, start, limit, nofilter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint provides a summary of the results generated by completed query runs for each  project specified in the the POST /queryjobs endpoint.  For completed query jobs, the summary includes:    * The number of results for successful query runs.   * Error information for failed query runs.  No information is included in the response for any project for which the query  run is still in progress.
         * @summary Provide a summary of results for the projects in the query job
         * @param {string} queryjobId The identifier of the query job, from the &#x60;task-result&#x60; given in the response to the initial &#x60;POST /queryjobs&#x60; request.
         * @param {string} [start] An opaque identifier generated by the API used for pagination.  This identifier will be included as part of the response for this endpoint whenever more than one page of results is available.
         * @param {number} [limit] The number of results to return. Useful for pagination.
         * @param {string} [filter] Only return a subset of results. Legal values are &#x60;w-results&#x60;, &#x60;wo-results&#x60;, &#x60;error&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryJobResultsOverview(queryjobId: string, start?: string, limit?: number, filter?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryjobResultsOverview> {
            const localVarAxiosArgs = QueryJobsApiAxiosParamCreator(configuration).getQueryJobResultsOverview(queryjobId, start, limit, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * QueryJobsApi - factory interface
 * @export
 */
export const QueryJobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Submit a query to run on one or more projects on LGTM. The query is included in the body of the request.
         * @summary Run a CodeQL query on one or more projects
         * @param {string} language The [language](https://lgtm.com/help/lgtm/analysis-faqs#which-languages-are-supported) you want to analyze.
         * @param {string} body The query to run.
         * @param {Array<number>} [projectId] The identifier of the project to analyze. Either &#x60;project-id&#x60; or &#x60;projects-list&#x60; must be specified.
         * @param {string} [projectsList] Name of the list containing the projects to analyze. Either &#x60;project-id&#x60; or &#x60;projects-list&#x60; must be specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryJob(language: string, body: string, projectId?: Array<number>, projectsList?: string, options?: any) {
            return QueryJobsApiFp(configuration).createQueryJob(language, body, projectId, projectsList, options)(axios, basePath);
        },
        /**
         * Get the status of a query job using the query job identifier for the task.  When you create a query job, the response includes a task result URL of the form: `/queryjobs/{queryjob-id}`.
         * @summary Get the status of a query job
         * @param {string} queryjobId The identifier of the query job, from the &#x60;task-result&#x60; given in the response to the initial &#x60;POST /queryjobs&#x60; request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryJob(queryjobId: string, options?: any) {
            return QueryJobsApiFp(configuration).getQueryJob(queryjobId, options)(axios, basePath);
        },
        /**
         * Fetch the results for a specific project. The endpoint succeeds only if the query was successful,  and returns a `404` error otherwise.  By default, the endpoint provides only results that are within the source tree. To obtain all results, specify the `nofilter` parameter.
         * @summary Fetch the results of a query job for a specific project
         * @param {string} queryjobId The identifier of the query job, from the &#x60;task-result&#x60; given in the response to the initial &#x60;POST /queryjobs&#x60; request.
         * @param {string} projectId The identifier for the project.
         * @param {number} [start] Start point for the page of results.
         * @param {number} [limit] The maximum number of results to display (less than 100).
         * @param {boolean} [nofilter] Include results that are not part of the source tree. These results are filtered out by default.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryJobResultsForProject(queryjobId: string, projectId: string, start?: number, limit?: number, nofilter?: boolean, options?: any) {
            return QueryJobsApiFp(configuration).getQueryJobResultsForProject(queryjobId, projectId, start, limit, nofilter, options)(axios, basePath);
        },
        /**
         * This endpoint provides a summary of the results generated by completed query runs for each  project specified in the the POST /queryjobs endpoint.  For completed query jobs, the summary includes:    * The number of results for successful query runs.   * Error information for failed query runs.  No information is included in the response for any project for which the query  run is still in progress.
         * @summary Provide a summary of results for the projects in the query job
         * @param {string} queryjobId The identifier of the query job, from the &#x60;task-result&#x60; given in the response to the initial &#x60;POST /queryjobs&#x60; request.
         * @param {string} [start] An opaque identifier generated by the API used for pagination.  This identifier will be included as part of the response for this endpoint whenever more than one page of results is available.
         * @param {number} [limit] The number of results to return. Useful for pagination.
         * @param {string} [filter] Only return a subset of results. Legal values are &#x60;w-results&#x60;, &#x60;wo-results&#x60;, &#x60;error&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryJobResultsOverview(queryjobId: string, start?: string, limit?: number, filter?: string, options?: any) {
            return QueryJobsApiFp(configuration).getQueryJobResultsOverview(queryjobId, start, limit, filter, options)(axios, basePath);
        },
    };
};

/**
 * QueryJobsApi - object-oriented interface
 * @export
 * @class QueryJobsApi
 * @extends {BaseAPI}
 */
export class QueryJobsApi extends BaseAPI {
    /**
     * Submit a query to run on one or more projects on LGTM. The query is included in the body of the request.
     * @summary Run a CodeQL query on one or more projects
     * @param {string} language The [language](https://lgtm.com/help/lgtm/analysis-faqs#which-languages-are-supported) you want to analyze.
     * @param {string} body The query to run.
     * @param {Array<number>} [projectId] The identifier of the project to analyze. Either &#x60;project-id&#x60; or &#x60;projects-list&#x60; must be specified.
     * @param {string} [projectsList] Name of the list containing the projects to analyze. Either &#x60;project-id&#x60; or &#x60;projects-list&#x60; must be specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryJobsApi
     */
    public createQueryJob(language: string, body: string, projectId?: Array<number>, projectsList?: string, options?: any) {
        return QueryJobsApiFp(this.configuration).createQueryJob(language, body, projectId, projectsList, options)(this.axios, this.basePath);
    }

    /**
     * Get the status of a query job using the query job identifier for the task.  When you create a query job, the response includes a task result URL of the form: `/queryjobs/{queryjob-id}`.
     * @summary Get the status of a query job
     * @param {string} queryjobId The identifier of the query job, from the &#x60;task-result&#x60; given in the response to the initial &#x60;POST /queryjobs&#x60; request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryJobsApi
     */
    public getQueryJob(queryjobId: string, options?: any) {
        return QueryJobsApiFp(this.configuration).getQueryJob(queryjobId, options)(this.axios, this.basePath);
    }

    /**
     * Fetch the results for a specific project. The endpoint succeeds only if the query was successful,  and returns a `404` error otherwise.  By default, the endpoint provides only results that are within the source tree. To obtain all results, specify the `nofilter` parameter.
     * @summary Fetch the results of a query job for a specific project
     * @param {string} queryjobId The identifier of the query job, from the &#x60;task-result&#x60; given in the response to the initial &#x60;POST /queryjobs&#x60; request.
     * @param {string} projectId The identifier for the project.
     * @param {number} [start] Start point for the page of results.
     * @param {number} [limit] The maximum number of results to display (less than 100).
     * @param {boolean} [nofilter] Include results that are not part of the source tree. These results are filtered out by default.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryJobsApi
     */
    public getQueryJobResultsForProject(queryjobId: string, projectId: string, start?: number, limit?: number, nofilter?: boolean, options?: any) {
        return QueryJobsApiFp(this.configuration).getQueryJobResultsForProject(queryjobId, projectId, start, limit, nofilter, options)(this.axios, this.basePath);
    }

    /**
     * This endpoint provides a summary of the results generated by completed query runs for each  project specified in the the POST /queryjobs endpoint.  For completed query jobs, the summary includes:    * The number of results for successful query runs.   * Error information for failed query runs.  No information is included in the response for any project for which the query  run is still in progress.
     * @summary Provide a summary of results for the projects in the query job
     * @param {string} queryjobId The identifier of the query job, from the &#x60;task-result&#x60; given in the response to the initial &#x60;POST /queryjobs&#x60; request.
     * @param {string} [start] An opaque identifier generated by the API used for pagination.  This identifier will be included as part of the response for this endpoint whenever more than one page of results is available.
     * @param {number} [limit] The number of results to return. Useful for pagination.
     * @param {string} [filter] Only return a subset of results. Legal values are &#x60;w-results&#x60;, &#x60;wo-results&#x60;, &#x60;error&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryJobsApi
     */
    public getQueryJobResultsOverview(queryjobId: string, start?: string, limit?: number, filter?: string, options?: any) {
        return QueryJobsApiFp(this.configuration).getQueryJobResultsOverview(queryjobId, start, limit, filter, options)(this.axios, this.basePath);
    }

}


/**
 * SnapshotsApi - axios parameter creator
 * @export
 */
export const SnapshotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Aborts the specified upload session and deletes any uploaded parts. After the session is aborted it cannot be restarted. If any part uploads are in progress when the session is aborted, their data may not be deleted. To ensure that uploaded parts are deleted correctly, you should only abort an upload session after all part uploads have completed.
         * @summary Abort database upload process
         * @param {string} sessionId The id of the upload session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abortUpload(sessionId: string, options: any = {}): RequestArgs {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling abortUpload.');
            }
            const localVarPath = `/snapshots/uploads/{session-id}`
                .replace(`{${"session-id"}}`, encodeURIComponent(String(sessionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes the database upload by closing the upload session, upgrading the database if appropriate, and scheduling analysis of that snapshot of the codebase.  You can view the analysis progress and access the results using the `task-result-url`.
         * @summary Complete snapshot upload session
         * @param {string} sessionId The id of the upload session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeUpload(sessionId: string, options: any = {}): RequestArgs {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling completeUpload.');
            }
            const localVarPath = `/snapshots/uploads/{session-id}`
                .replace(`{${"session-id"}}`, encodeURIComponent(String(sessionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download a CodeQL database from LGTM, representing a snapshot of the codebase, to run queries in your IDE.  This endpoint works for projects that have been successfully analyzed for the language specified in the request.  A successful request redirects you to a URL for downloading a database that represents the code snapshot, as specified in the `Location:` header in the response. Therefore, your HTTP client should be configured to follow redirects. For example, if you are using `curl`, you can add the`-L` flag to the command. For both LGTM.com and LGTM Enterprise, you must include an access token with the `snapshots:read` scope.  The database is downloaded as a zip file that can be imported into an IDE equipped with a  CodeQL extension or plugin for local analysis. The extension or plugin must be up to date to anaylze databases downloaded from LGTM. For more information on running queries locally in your IDE, see [Runnning queries in your IDE](https://lgtm.com/help/lgtm/running-queries-ide).
         * @summary Download a snapshot
         * @param {number} projectId The numeric project identifier.
         * @param {string} language The language of the database to download.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshot(projectId: number, language: string, options: any = {}): RequestArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling getSnapshot.');
            }
            // verify required parameter 'language' is not null or undefined
            if (language === null || language === undefined) {
                throw new RequiredError('language','Required parameter language was null or undefined when calling getSnapshot.');
            }
            const localVarPath = `/snapshots/{project-id}/{language}`
                .replace(`{${"project-id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a session to upload an externally-built database (which represents a snapshot of a codebase) to a project on LGTM.   This endpoint works for projects that are already on LGTM, and the selected language of  the database must already be configured. The project must be configured with \'upload\' analysis mode. You can upload a \"bundled\" CodeQL database or a database exported by  the QL command-line tools (`odasa`).  If your database was generated using a version of the  command line that is older than LGTM,  LGTM will try to upgrade and analyze it when the upload is complete. You can include cached predicates in the upload, but they are ignored as the cache is  repopulated after the database has been upgraded and analyzed. However, if you want to include results with your database, make sure the database is  compatible before you start the upload session.  Incompatible databases with results won\'t be upgraded and therefore cannot be uploaded.  For further information on externally-built databases,  see [Preparing snapshots to upload to LGTM using the QL command-line tools](https://help.semmle.com/wiki/display/SD/Preparing+snapshots+to+upload+to+LGTM).       When the upload session has been successfully started, upload the database to the  upload URL returned in the response. The database can be uploaded to the upload URL in parts using  the [`PUT /snapshots/uploads/{session-id}`](https://lgtm.com/help/lgtm/api/api-v1#opIduploadPart) endpoint. After uploading all the parts you must call  the [`POST /snapshots/uploads/{session-id}`](https://lgtm.com/help/lgtm/api/api-v1#opIdcompleteUpload) endpoint to complete the upload session.
         * @summary Start snapshot upload session
         * @param {number} projectId The numeric project identifier.
         * @param {string} language The language of the database to upload.
         * @param {string} commit The identifier of the analyzed commit.
         * @param {Date} [date] The date and time of the analyzed commit (default the current time).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initSnapshotUpload(projectId: number, language: string, commit: string, date?: Date, options: any = {}): RequestArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling initSnapshotUpload.');
            }
            // verify required parameter 'language' is not null or undefined
            if (language === null || language === undefined) {
                throw new RequiredError('language','Required parameter language was null or undefined when calling initSnapshotUpload.');
            }
            // verify required parameter 'commit' is not null or undefined
            if (commit === null || commit === undefined) {
                throw new RequiredError('commit','Required parameter commit was null or undefined when calling initSnapshotUpload.');
            }
            const localVarPath = `/snapshots/{project-id}/{language}`
                .replace(`{${"project-id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (commit !== undefined) {
                localVarQueryParameter['commit'] = commit;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any).toISOString();
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a database representing a snapshot of a codebase.  The database is sent in one or more parts. Each part is sent in the request body.  Use the [`POST /snapshots/{project-id}/{language}`](https://lgtm.com/help/lgtm/api/api-v1#opIdinitSnapshotUpload) endpoint  to start an upload session before uploading a database part. Database parts must have been generated and prepared for upload using the CodeQL CLI or the QL command-line tools. For further information on exporting externally-built databases,  see [Preparing snapshots to upload to LGTM](https://help.semmle.com/wiki/display/SD/Preparing+snapshots+to+upload+to+LGTM).  Split large databases into multiple parts. Upload the parts by making a separate request for each part.  Don\'t upload the next part until you\'ve successfully uploaded the previous part.  If the upload fails you should retry it with the same data.
         * @summary Upload snapshot
         * @param {string} sessionId The id of the upload session.
         * @param {any} body The database or database part to upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPart(sessionId: string, body: any, options: any = {}): RequestArgs {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling uploadPart.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling uploadPart.');
            }
            const localVarPath = `/snapshots/uploads/{session-id}`
                .replace(`{${"session-id"}}`, encodeURIComponent(String(sessionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarHeaderParameter['Content-Type'] = 'application/zip';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SnapshotsApi - functional programming interface
 * @export
 */
export const SnapshotsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Aborts the specified upload session and deletes any uploaded parts. After the session is aborted it cannot be restarted. If any part uploads are in progress when the session is aborted, their data may not be deleted. To ensure that uploaded parts are deleted correctly, you should only abort an upload session after all part uploads have completed.
         * @summary Abort database upload process
         * @param {string} sessionId The id of the upload session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abortUpload(sessionId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation> {
            const localVarAxiosArgs = SnapshotsApiAxiosParamCreator(configuration).abortUpload(sessionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Completes the database upload by closing the upload session, upgrading the database if appropriate, and scheduling analysis of that snapshot of the codebase.  You can view the analysis progress and access the results using the `task-result-url`.
         * @summary Complete snapshot upload session
         * @param {string} sessionId The id of the upload session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeUpload(sessionId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation> {
            const localVarAxiosArgs = SnapshotsApiAxiosParamCreator(configuration).completeUpload(sessionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Download a CodeQL database from LGTM, representing a snapshot of the codebase, to run queries in your IDE.  This endpoint works for projects that have been successfully analyzed for the language specified in the request.  A successful request redirects you to a URL for downloading a database that represents the code snapshot, as specified in the `Location:` header in the response. Therefore, your HTTP client should be configured to follow redirects. For example, if you are using `curl`, you can add the`-L` flag to the command. For both LGTM.com and LGTM Enterprise, you must include an access token with the `snapshots:read` scope.  The database is downloaded as a zip file that can be imported into an IDE equipped with a  CodeQL extension or plugin for local analysis. The extension or plugin must be up to date to anaylze databases downloaded from LGTM. For more information on running queries locally in your IDE, see [Runnning queries in your IDE](https://lgtm.com/help/lgtm/running-queries-ide).
         * @summary Download a snapshot
         * @param {number} projectId The numeric project identifier.
         * @param {string} language The language of the database to download.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshot(projectId: number, language: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = SnapshotsApiAxiosParamCreator(configuration).getSnapshot(projectId, language, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Start a session to upload an externally-built database (which represents a snapshot of a codebase) to a project on LGTM.   This endpoint works for projects that are already on LGTM, and the selected language of  the database must already be configured. The project must be configured with \'upload\' analysis mode. You can upload a \"bundled\" CodeQL database or a database exported by  the QL command-line tools (`odasa`).  If your database was generated using a version of the  command line that is older than LGTM,  LGTM will try to upgrade and analyze it when the upload is complete. You can include cached predicates in the upload, but they are ignored as the cache is  repopulated after the database has been upgraded and analyzed. However, if you want to include results with your database, make sure the database is  compatible before you start the upload session.  Incompatible databases with results won\'t be upgraded and therefore cannot be uploaded.  For further information on externally-built databases,  see [Preparing snapshots to upload to LGTM using the QL command-line tools](https://help.semmle.com/wiki/display/SD/Preparing+snapshots+to+upload+to+LGTM).       When the upload session has been successfully started, upload the database to the  upload URL returned in the response. The database can be uploaded to the upload URL in parts using  the [`PUT /snapshots/uploads/{session-id}`](https://lgtm.com/help/lgtm/api/api-v1#opIduploadPart) endpoint. After uploading all the parts you must call  the [`POST /snapshots/uploads/{session-id}`](https://lgtm.com/help/lgtm/api/api-v1#opIdcompleteUpload) endpoint to complete the upload session.
         * @summary Start snapshot upload session
         * @param {number} projectId The numeric project identifier.
         * @param {string} language The language of the database to upload.
         * @param {string} commit The identifier of the analyzed commit.
         * @param {Date} [date] The date and time of the analyzed commit (default the current time).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initSnapshotUpload(projectId: number, language: string, commit: string, date?: Date, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadSession> {
            const localVarAxiosArgs = SnapshotsApiAxiosParamCreator(configuration).initSnapshotUpload(projectId, language, commit, date, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upload a database representing a snapshot of a codebase.  The database is sent in one or more parts. Each part is sent in the request body.  Use the [`POST /snapshots/{project-id}/{language}`](https://lgtm.com/help/lgtm/api/api-v1#opIdinitSnapshotUpload) endpoint  to start an upload session before uploading a database part. Database parts must have been generated and prepared for upload using the CodeQL CLI or the QL command-line tools. For further information on exporting externally-built databases,  see [Preparing snapshots to upload to LGTM](https://help.semmle.com/wiki/display/SD/Preparing+snapshots+to+upload+to+LGTM).  Split large databases into multiple parts. Upload the parts by making a separate request for each part.  Don\'t upload the next part until you\'ve successfully uploaded the previous part.  If the upload fails you should retry it with the same data.
         * @summary Upload snapshot
         * @param {string} sessionId The id of the upload session.
         * @param {any} body The database or database part to upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPart(sessionId: string, body: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = SnapshotsApiAxiosParamCreator(configuration).uploadPart(sessionId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SnapshotsApi - factory interface
 * @export
 */
export const SnapshotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Aborts the specified upload session and deletes any uploaded parts. After the session is aborted it cannot be restarted. If any part uploads are in progress when the session is aborted, their data may not be deleted. To ensure that uploaded parts are deleted correctly, you should only abort an upload session after all part uploads have completed.
         * @summary Abort database upload process
         * @param {string} sessionId The id of the upload session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abortUpload(sessionId: string, options?: any) {
            return SnapshotsApiFp(configuration).abortUpload(sessionId, options)(axios, basePath);
        },
        /**
         * Completes the database upload by closing the upload session, upgrading the database if appropriate, and scheduling analysis of that snapshot of the codebase.  You can view the analysis progress and access the results using the `task-result-url`.
         * @summary Complete snapshot upload session
         * @param {string} sessionId The id of the upload session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeUpload(sessionId: string, options?: any) {
            return SnapshotsApiFp(configuration).completeUpload(sessionId, options)(axios, basePath);
        },
        /**
         * Download a CodeQL database from LGTM, representing a snapshot of the codebase, to run queries in your IDE.  This endpoint works for projects that have been successfully analyzed for the language specified in the request.  A successful request redirects you to a URL for downloading a database that represents the code snapshot, as specified in the `Location:` header in the response. Therefore, your HTTP client should be configured to follow redirects. For example, if you are using `curl`, you can add the`-L` flag to the command. For both LGTM.com and LGTM Enterprise, you must include an access token with the `snapshots:read` scope.  The database is downloaded as a zip file that can be imported into an IDE equipped with a  CodeQL extension or plugin for local analysis. The extension or plugin must be up to date to anaylze databases downloaded from LGTM. For more information on running queries locally in your IDE, see [Runnning queries in your IDE](https://lgtm.com/help/lgtm/running-queries-ide).
         * @summary Download a snapshot
         * @param {number} projectId The numeric project identifier.
         * @param {string} language The language of the database to download.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshot(projectId: number, language: string, options?: any) {
            return SnapshotsApiFp(configuration).getSnapshot(projectId, language, options)(axios, basePath);
        },
        /**
         * Start a session to upload an externally-built database (which represents a snapshot of a codebase) to a project on LGTM.   This endpoint works for projects that are already on LGTM, and the selected language of  the database must already be configured. The project must be configured with \'upload\' analysis mode. You can upload a \"bundled\" CodeQL database or a database exported by  the QL command-line tools (`odasa`).  If your database was generated using a version of the  command line that is older than LGTM,  LGTM will try to upgrade and analyze it when the upload is complete. You can include cached predicates in the upload, but they are ignored as the cache is  repopulated after the database has been upgraded and analyzed. However, if you want to include results with your database, make sure the database is  compatible before you start the upload session.  Incompatible databases with results won\'t be upgraded and therefore cannot be uploaded.  For further information on externally-built databases,  see [Preparing snapshots to upload to LGTM using the QL command-line tools](https://help.semmle.com/wiki/display/SD/Preparing+snapshots+to+upload+to+LGTM).       When the upload session has been successfully started, upload the database to the  upload URL returned in the response. The database can be uploaded to the upload URL in parts using  the [`PUT /snapshots/uploads/{session-id}`](https://lgtm.com/help/lgtm/api/api-v1#opIduploadPart) endpoint. After uploading all the parts you must call  the [`POST /snapshots/uploads/{session-id}`](https://lgtm.com/help/lgtm/api/api-v1#opIdcompleteUpload) endpoint to complete the upload session.
         * @summary Start snapshot upload session
         * @param {number} projectId The numeric project identifier.
         * @param {string} language The language of the database to upload.
         * @param {string} commit The identifier of the analyzed commit.
         * @param {Date} [date] The date and time of the analyzed commit (default the current time).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initSnapshotUpload(projectId: number, language: string, commit: string, date?: Date, options?: any) {
            return SnapshotsApiFp(configuration).initSnapshotUpload(projectId, language, commit, date, options)(axios, basePath);
        },
        /**
         * Upload a database representing a snapshot of a codebase.  The database is sent in one or more parts. Each part is sent in the request body.  Use the [`POST /snapshots/{project-id}/{language}`](https://lgtm.com/help/lgtm/api/api-v1#opIdinitSnapshotUpload) endpoint  to start an upload session before uploading a database part. Database parts must have been generated and prepared for upload using the CodeQL CLI or the QL command-line tools. For further information on exporting externally-built databases,  see [Preparing snapshots to upload to LGTM](https://help.semmle.com/wiki/display/SD/Preparing+snapshots+to+upload+to+LGTM).  Split large databases into multiple parts. Upload the parts by making a separate request for each part.  Don\'t upload the next part until you\'ve successfully uploaded the previous part.  If the upload fails you should retry it with the same data.
         * @summary Upload snapshot
         * @param {string} sessionId The id of the upload session.
         * @param {any} body The database or database part to upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPart(sessionId: string, body: any, options?: any) {
            return SnapshotsApiFp(configuration).uploadPart(sessionId, body, options)(axios, basePath);
        },
    };
};

/**
 * SnapshotsApi - object-oriented interface
 * @export
 * @class SnapshotsApi
 * @extends {BaseAPI}
 */
export class SnapshotsApi extends BaseAPI {
    /**
     * Aborts the specified upload session and deletes any uploaded parts. After the session is aborted it cannot be restarted. If any part uploads are in progress when the session is aborted, their data may not be deleted. To ensure that uploaded parts are deleted correctly, you should only abort an upload session after all part uploads have completed.
     * @summary Abort database upload process
     * @param {string} sessionId The id of the upload session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public abortUpload(sessionId: string, options?: any) {
        return SnapshotsApiFp(this.configuration).abortUpload(sessionId, options)(this.axios, this.basePath);
    }

    /**
     * Completes the database upload by closing the upload session, upgrading the database if appropriate, and scheduling analysis of that snapshot of the codebase.  You can view the analysis progress and access the results using the `task-result-url`.
     * @summary Complete snapshot upload session
     * @param {string} sessionId The id of the upload session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public completeUpload(sessionId: string, options?: any) {
        return SnapshotsApiFp(this.configuration).completeUpload(sessionId, options)(this.axios, this.basePath);
    }

    /**
     * Download a CodeQL database from LGTM, representing a snapshot of the codebase, to run queries in your IDE.  This endpoint works for projects that have been successfully analyzed for the language specified in the request.  A successful request redirects you to a URL for downloading a database that represents the code snapshot, as specified in the `Location:` header in the response. Therefore, your HTTP client should be configured to follow redirects. For example, if you are using `curl`, you can add the`-L` flag to the command. For both LGTM.com and LGTM Enterprise, you must include an access token with the `snapshots:read` scope.  The database is downloaded as a zip file that can be imported into an IDE equipped with a  CodeQL extension or plugin for local analysis. The extension or plugin must be up to date to anaylze databases downloaded from LGTM. For more information on running queries locally in your IDE, see [Runnning queries in your IDE](https://lgtm.com/help/lgtm/running-queries-ide).
     * @summary Download a snapshot
     * @param {number} projectId The numeric project identifier.
     * @param {string} language The language of the database to download.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public getSnapshot(projectId: number, language: string, options?: any) {
        return SnapshotsApiFp(this.configuration).getSnapshot(projectId, language, options)(this.axios, this.basePath);
    }

    /**
     * Start a session to upload an externally-built database (which represents a snapshot of a codebase) to a project on LGTM.   This endpoint works for projects that are already on LGTM, and the selected language of  the database must already be configured. The project must be configured with \'upload\' analysis mode. You can upload a \"bundled\" CodeQL database or a database exported by  the QL command-line tools (`odasa`).  If your database was generated using a version of the  command line that is older than LGTM,  LGTM will try to upgrade and analyze it when the upload is complete. You can include cached predicates in the upload, but they are ignored as the cache is  repopulated after the database has been upgraded and analyzed. However, if you want to include results with your database, make sure the database is  compatible before you start the upload session.  Incompatible databases with results won\'t be upgraded and therefore cannot be uploaded.  For further information on externally-built databases,  see [Preparing snapshots to upload to LGTM using the QL command-line tools](https://help.semmle.com/wiki/display/SD/Preparing+snapshots+to+upload+to+LGTM).       When the upload session has been successfully started, upload the database to the  upload URL returned in the response. The database can be uploaded to the upload URL in parts using  the [`PUT /snapshots/uploads/{session-id}`](https://lgtm.com/help/lgtm/api/api-v1#opIduploadPart) endpoint. After uploading all the parts you must call  the [`POST /snapshots/uploads/{session-id}`](https://lgtm.com/help/lgtm/api/api-v1#opIdcompleteUpload) endpoint to complete the upload session.
     * @summary Start snapshot upload session
     * @param {number} projectId The numeric project identifier.
     * @param {string} language The language of the database to upload.
     * @param {string} commit The identifier of the analyzed commit.
     * @param {Date} [date] The date and time of the analyzed commit (default the current time).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public initSnapshotUpload(projectId: number, language: string, commit: string, date?: Date, options?: any) {
        return SnapshotsApiFp(this.configuration).initSnapshotUpload(projectId, language, commit, date, options)(this.axios, this.basePath);
    }

    /**
     * Upload a database representing a snapshot of a codebase.  The database is sent in one or more parts. Each part is sent in the request body.  Use the [`POST /snapshots/{project-id}/{language}`](https://lgtm.com/help/lgtm/api/api-v1#opIdinitSnapshotUpload) endpoint  to start an upload session before uploading a database part. Database parts must have been generated and prepared for upload using the CodeQL CLI or the QL command-line tools. For further information on exporting externally-built databases,  see [Preparing snapshots to upload to LGTM](https://help.semmle.com/wiki/display/SD/Preparing+snapshots+to+upload+to+LGTM).  Split large databases into multiple parts. Upload the parts by making a separate request for each part.  Don\'t upload the next part until you\'ve successfully uploaded the previous part.  If the upload fails you should retry it with the same data.
     * @summary Upload snapshot
     * @param {string} sessionId The id of the upload session.
     * @param {any} body The database or database part to upload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public uploadPart(sessionId: string, body: any, options?: any) {
        return SnapshotsApiFp(this.configuration).uploadPart(sessionId, body, options)(this.axios, this.basePath);
    }

}


/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return an indication of whether the application is working as expected (up) or needs  attention (down).  \\> The `description` and `details` fields are reported only if the request includes an access token for a user account that has administration rights for this LGTM server.
         * @summary Get a summary of the application\'s health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options: any = {}): RequestArgs {
            const localVarPath = `/system/health`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * LGTM administrators can download usage data using this endpoint. The response includes up to 1000 values for the specified metric and reports the date-time that each value was calculated. There is normally one value per day.
         * @summary Get the computed values of the specified metric
         * @param {string} metricId The identifier of the metric.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetric(metricId: string, options: any = {}): RequestArgs {
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling getMetric.');
            }
            const localVarPath = `/system/metrics/{metric-id}`
                .replace(`{${"metric-id"}}`, encodeURIComponent(String(metricId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * LGTM administrators can use this endpoint to list the usage metrics that are available to download.
         * @summary Get the identifiers and descriptions of the usage metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(options: any = {}): RequestArgs {
            const localVarPath = `/system/metrics`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return an indication of whether the application is working as expected (up) or needs  attention (down).  \\> The `description` and `details` fields are reported only if the request includes an access token for a user account that has administration rights for this LGTM server.
         * @summary Get a summary of the application\'s health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health> {
            const localVarAxiosArgs = SystemApiAxiosParamCreator(configuration).getHealth(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * LGTM administrators can download usage data using this endpoint. The response includes up to 1000 values for the specified metric and reports the date-time that each value was calculated. There is normally one value per day.
         * @summary Get the computed values of the specified metric
         * @param {string} metricId The identifier of the metric.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetric(metricId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metric> {
            const localVarAxiosArgs = SystemApiAxiosParamCreator(configuration).getMetric(metricId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * LGTM administrators can use this endpoint to list the usage metrics that are available to download.
         * @summary Get the identifiers and descriptions of the usage metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsList> {
            const localVarAxiosArgs = SystemApiAxiosParamCreator(configuration).getMetrics(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Return an indication of whether the application is working as expected (up) or needs  attention (down).  \\> The `description` and `details` fields are reported only if the request includes an access token for a user account that has administration rights for this LGTM server.
         * @summary Get a summary of the application\'s health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options?: any) {
            return SystemApiFp(configuration).getHealth(options)(axios, basePath);
        },
        /**
         * LGTM administrators can download usage data using this endpoint. The response includes up to 1000 values for the specified metric and reports the date-time that each value was calculated. There is normally one value per day.
         * @summary Get the computed values of the specified metric
         * @param {string} metricId The identifier of the metric.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetric(metricId: string, options?: any) {
            return SystemApiFp(configuration).getMetric(metricId, options)(axios, basePath);
        },
        /**
         * LGTM administrators can use this endpoint to list the usage metrics that are available to download.
         * @summary Get the identifiers and descriptions of the usage metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(options?: any) {
            return SystemApiFp(configuration).getMetrics(options)(axios, basePath);
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * Return an indication of whether the application is working as expected (up) or needs  attention (down).  \\> The `description` and `details` fields are reported only if the request includes an access token for a user account that has administration rights for this LGTM server.
     * @summary Get a summary of the application\'s health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getHealth(options?: any) {
        return SystemApiFp(this.configuration).getHealth(options)(this.axios, this.basePath);
    }

    /**
     * LGTM administrators can download usage data using this endpoint. The response includes up to 1000 values for the specified metric and reports the date-time that each value was calculated. There is normally one value per day.
     * @summary Get the computed values of the specified metric
     * @param {string} metricId The identifier of the metric.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getMetric(metricId: string, options?: any) {
        return SystemApiFp(this.configuration).getMetric(metricId, options)(this.axios, this.basePath);
    }

    /**
     * LGTM administrators can use this endpoint to list the usage metrics that are available to download.
     * @summary Get the identifiers and descriptions of the usage metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getMetrics(options?: any) {
        return SystemApiFp(this.configuration).getMetrics(options)(this.axios, this.basePath);
    }

}


